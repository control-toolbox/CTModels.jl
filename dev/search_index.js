var documenterSearchIndex = {"docs":
[{"location":"dev.html#Private-functions","page":"Developers","title":"Private functions","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"CollapsedDocStrings = false\nCurrentModule =  CTModels","category":"page"},{"location":"dev.html#CTModels","page":"Developers","title":"CTModels","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Pages   = [\"CTModels.jl\"]\nModules = [CTModels]\nOrder   = [:module]","category":"page"},{"location":"dev.html#CTModels.CTModels","page":"Developers","title":"CTModels.CTModels","text":"CTModels module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nInterpolations\nMLStyle\nParameters\nPrettyTables\n\nList of all the exported names:\n\nplot\nplot!\n\n\n\n\n\n","category":"module"},{"location":"dev.html#Index","page":"Developers","title":"Index","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Pages   = [\"dev.md\"]\nModules = [CTModels]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"dev.html#Documentation","page":"Developers","title":"Documentation","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Modules = [CTModels]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"dev.html#CTModels.TimesDisc","page":"Developers","title":"CTModels.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractConstraintsModel","page":"Developers","title":"CTModels.AbstractConstraintsModel","text":"abstract type AbstractConstraintsModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractControlModel","page":"Developers","title":"CTModels.AbstractControlModel","text":"abstract type AbstractControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractDualModel","page":"Developers","title":"CTModels.AbstractDualModel","text":"abstract type AbstractDualModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractModel","page":"Developers","title":"CTModels.AbstractModel","text":"abstract type AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractObjectiveModel","page":"Developers","title":"CTModels.AbstractObjectiveModel","text":"abstract type AbstractObjectiveModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractSolution","page":"Developers","title":"CTModels.AbstractSolution","text":"abstract type AbstractSolution\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractSolverInfos","page":"Developers","title":"CTModels.AbstractSolverInfos","text":"abstract type AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractStateModel","page":"Developers","title":"CTModels.AbstractStateModel","text":"abstract type AbstractStateModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTag","page":"Developers","title":"CTModels.AbstractTag","text":"abstract type AbstractTag\n\nAbstract type for export/import functions, used to choose between JSON or JLD extensions.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTimeGridModel","page":"Developers","title":"CTModels.AbstractTimeGridModel","text":"abstract type AbstractTimeGridModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTimeModel","page":"Developers","title":"CTModels.AbstractTimeModel","text":"abstract type AbstractTimeModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTimesModel","page":"Developers","title":"CTModels.AbstractTimesModel","text":"abstract type AbstractTimesModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractVariableModel","page":"Developers","title":"CTModels.AbstractVariableModel","text":"abstract type AbstractVariableModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.BolzaObjectiveModel","page":"Developers","title":"CTModels.BolzaObjectiveModel","text":"struct BolzaObjectiveModel{TM<:Function, TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ConstraintsDictType","page":"Developers","title":"CTModels.ConstraintsDictType","text":"Type alias for a dictionnary of constraints. This is used to store constraints before building the model.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: ConstraintsModel, PreModel and Model.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ConstraintsModel","page":"Developers","title":"CTModels.ConstraintsModel","text":"struct ConstraintsModel{TP<:Tuple, TB<:Tuple, TS<:Tuple, TC<:Tuple, TV<:Tuple, TC_ALL<:Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} <: CTModels.AbstractConstraintsModel\n\nFields\n\npath_nl::Tuple\nboundary_nl::Tuple\nstate_box::Tuple\ncontrol_box::Tuple\nvariable_box::Tuple\ndict::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ControlModel","page":"Developers","title":"CTModels.ControlModel","text":"struct ControlModel <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ControlModelSolution","page":"Developers","title":"CTModels.ControlModelSolution","text":"struct ControlModelSolution{TS<:Function} <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Dimension","page":"Developers","title":"CTModels.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.DualModel","page":"Developers","title":"CTModels.DualModel","text":"struct DualModel{PC<:Union{Nothing, Function}, PC_Dual<:Union{Nothing, Function}, BC<:Union{Nothing, AbstractVector{<:Real}}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}} <: CTModels.AbstractDualModel\n\nFields\n\npath_constraints::Union{Nothing, Function}\npath_constraints_dual::Union{Nothing, Function}\nboundary_constraints::Union{Nothing, AbstractVector{<:Real}}\nboundary_constraints_dual::Union{Nothing, AbstractVector{<:Real}}\nstate_constraints_lb_dual::Union{Nothing, Function}\nstate_constraints_ub_dual::Union{Nothing, Function}\ncontrol_constraints_lb_dual::Union{Nothing, Function}\ncontrol_constraints_ub_dual::Union{Nothing, Function}\nvariable_constraints_lb_dual::Union{Nothing, AbstractVector{<:Real}}\nvariable_constraints_ub_dual::Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.EmptyTimeGridModel","page":"Developers","title":"CTModels.EmptyTimeGridModel","text":"struct EmptyTimeGridModel <: CTModels.AbstractTimeGridModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.EmptyVariableModel","page":"Developers","title":"CTModels.EmptyVariableModel","text":"struct EmptyVariableModel <: CTModels.AbstractVariableModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.FixedTimeModel","page":"Developers","title":"CTModels.FixedTimeModel","text":"struct FixedTimeModel{T<:Real} <: CTModels.AbstractTimeModel\n\nFields\n\ntime::Real\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.FreeTimeModel","page":"Developers","title":"CTModels.FreeTimeModel","text":"struct FreeTimeModel <: CTModels.AbstractTimeModel\n\nFields\n\nindex::Int64\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Init","page":"Developers","title":"CTModels.Init","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nInit(): default initialization\nInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nInit(sol): from existing solution\n\nExamples\n\njulia> init = Init()\njulia> init = Init(state=[0.1, 0.2], control=0.3)\njulia> init = Init(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = Init(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = Init(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = Init(sol)\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.JLD2Tag","page":"Developers","title":"CTModels.JLD2Tag","text":"struct JLD2Tag <: CTModels.AbstractTag\n\nJLD tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.JSON3Tag","page":"Developers","title":"CTModels.JSON3Tag","text":"struct JSON3Tag <: CTModels.AbstractTag\n\nJSON tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.LagrangeObjectiveModel","page":"Developers","title":"CTModels.LagrangeObjectiveModel","text":"struct LagrangeObjectiveModel{TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.MayerObjectiveModel","page":"Developers","title":"CTModels.MayerObjectiveModel","text":"struct MayerObjectiveModel{TM<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Model","page":"Developers","title":"CTModels.Model","text":"struct Model{TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.PreModel","page":"Developers","title":"CTModels.PreModel","text":"mutable struct PreModel <: CTModels.AbstractModel\n\nFields\n\ntimes::Union{Nothing, CTModels.AbstractTimesModel}: Default: nothing\nstate::Union{Nothing, CTModels.AbstractStateModel}: Default: nothing\ncontrol::Union{Nothing, CTModels.AbstractControlModel}: Default: nothing\nvariable::CTModels.AbstractVariableModel: Default: EmptyVariableModel()\ndynamics::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, CTModels.AbstractObjectiveModel}: Default: nothing\nconstraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}: Default: ConstraintsDictType()\ndefinition::Union{Nothing, Expr}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Solution","page":"Developers","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.SolverInfos","page":"Developers","title":"CTModels.SolverInfos","text":"struct SolverInfos{TI<:Dict{Symbol, Any}} <: CTModels.AbstractSolverInfos\n\nFields\n\niterations::Int64\nstopping::Symbol\nmessage::String\nsuccess::Bool\nconstraints_violation::Float64\ninfos::Dict{Symbol, Any}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.StateModel","page":"Developers","title":"CTModels.StateModel","text":"struct StateModel <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.StateModelSolution","page":"Developers","title":"CTModels.StateModelSolution","text":"struct StateModelSolution{TS<:Function} <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Time","page":"Developers","title":"CTModels.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.TimeGridModel","page":"Developers","title":"CTModels.TimeGridModel","text":"struct TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}} <: CTModels.AbstractTimeGridModel\n\nFields\n\nvalue::Union{StepRangeLen, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Times","page":"Developers","title":"CTModels.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.TimesModel","page":"Developers","title":"CTModels.TimesModel","text":"struct TimesModel{TI<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel} <: CTModels.AbstractTimesModel\n\nFields\n\ninitial::CTModels.AbstractTimeModel\nfinal::CTModels.AbstractTimeModel\ntime_name::String\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.VariableModel","page":"Developers","title":"CTModels.VariableModel","text":"struct VariableModel <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.VariableModelSolution","page":"Developers","title":"CTModels.VariableModelSolution","text":"struct VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}} <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ctNumber","page":"Developers","title":"CTModels.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ctVector","page":"Developers","title":"CTModels.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = AbstractVector{<:ctNumber}\n\nSee also: ctNumber.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#Base.isempty-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"Base.isempty","text":"isempty(model::CTModels.ConstraintsModel) -> Bool\n\n\nReturn if the constraints model is not empty.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Model}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.Model\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.PreModel}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.PreModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Solution}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::CTModels.Solution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show_default-Tuple{IO, CTModels.PreModel}","page":"Developers","title":"Base.show_default","text":"show_default(io::IO, ocp::CTModels.PreModel)\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show_default-Tuple{IO, CTModels.Solution}","page":"Developers","title":"Base.show_default","text":"show_default(io::IO, sol::CTModels.Solution)\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__constraint!-Tuple{Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}, Symbol, Int64, Int64, Int64}","page":"Developers","title":"CTModels.__constraint!","text":"__constraint!(\n    ocp_constraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}},\n    type::Symbol,\n    n::Int64,\n    m::Int64,\n    q::Int64;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a dictionary of constraints.\n\nArguments\n\nocp_constraints: The dictionary of constraints to which the constraint will be added.\ntype: The type of the constraint. It can be :state, :control, :variable, :boundary or :path.\nn: The dimension of the state.\nm: The dimension of the control.\nq: The dimension of the variable.\nrg: The range of the constraint. It can be an integer or a range of integers.\nf: The function that defines the constraint. It must return a vector of the same dimension as the constraint.\nlb: The lower bound of the constraint. It can be a number or a vector.\nub: The upper bound of the constraint. It can be a number or a vector.\nlabel: The label of the constraint. It must be unique in the dictionary of constraints.\n\nRequirements\n\nThe constraint must not be set before.\nThe lower bound lb and the upper bound ub cannot be both nothing.\nThe lower bound lb and the upper bound ub must have the same length, if both provided.\n\nIf rg and f are not provided then, \n\ntype must be :state, :control or :variable\nlb and ub must be of dimension n, m or q respectively, when provided.\n\nIf rg is provided, then:\n\nf must not be provided.\ntype must be :state, :control or :variable.\nrg must be a range of integers, and must be contained in 1:n, 1:m or 1:q respectively.\n\nIf f is provided, then:\n\nrg must not be provided.\ntype must be :boundary or :path.\nf must be a function that returns a vector of the same dimension as the constraint.\nlb and ub must be of the same dimension as the output of f, when provided.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__constraint_label-Tuple{}","page":"Developers","title":"CTModels.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__constraints-Tuple{}","page":"Developers","title":"CTModels.__constraints","text":"__constraints()\n\n\nUsed to set the default value for the constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__control_components-Tuple{Int64, String}","page":"Developers","title":"CTModels.__control_components","text":"__control_components(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__control_name-Tuple{}","page":"Developers","title":"CTModels.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__criterion_type-Tuple{}","page":"Developers","title":"CTModels.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__format-Tuple{}","page":"Developers","title":"CTModels.__format","text":"__format() -> Symbol\n\n\nUsed to set the default value of the format of the file to be used for export and import.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_consistent-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_consistent","text":"__is_consistent(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_control_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_control_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_definition_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_definition_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_dynamics_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_dynamics_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_empty-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_empty","text":"__is_empty(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_objective_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_objective_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_state_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_state_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_times_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_times_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_variable_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_variable_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__state_components-Tuple{Int64, String}","page":"Developers","title":"CTModels.__state_components","text":"__state_components(n::Int64, name::String) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__state_name-Tuple{}","page":"Developers","title":"CTModels.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__time_name-Tuple{}","page":"Developers","title":"CTModels.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__variable_components-Tuple{Int64, String}","page":"Developers","title":"CTModels.__variable_components","text":"__variable_components(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__variable_name-Tuple{Int64}","page":"Developers","title":"CTModels.__variable_name","text":"__variable_name(q::Int64) -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.boundary_constraints","text":"boundary_constraints(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, BC}}, Tuple{BC}} where BC<:Union{Nothing, Function}","page":"Developers","title":"CTModels.boundary_constraints","text":"boundary_constraints(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, BC<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the dual of the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, BC_Dual}}, Tuple{BC_Dual}} where BC_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, BC_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, TB}}, Tuple{TB}} where TB","page":"Developers","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    model::CTModels.ConstraintsModel{<:Tuple, TB}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB}}}, Tuple{TB}} where TB<:Tuple","page":"Developers","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB<:Tuple}}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Any, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTModels.var\"#18#19\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Function, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTModels.var\"#20#21\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTModels.var\"#18#19\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTModels.var\"#22#24\", CTModels.var\"#23#25\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildVectorInit-Tuple{Any, Any}","page":"Developers","title":"CTModels.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.build_constraints-Tuple{Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}}","page":"Developers","title":"CTModels.build_constraints","text":"build_constraints(\n    constraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n) -> CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}}}\n\n\nBuild a concrete type constraints model from a dictionary of constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.build_model-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.build_model","text":"build_model(\n    pre_ocp::CTModels.PreModel\n) -> CTModels.Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType} where {TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:(CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}}})}\n\n\nBuild a concrete type model from a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.build_solution-Union{Tuple{TP}, Tuple{TU}, Tuple{TX}, Tuple{CTModels.Model, Vector{Float64}, TX, TU, Vector{Float64}, TP}} where {TX<:Union{Function, Matrix{Float64}}, TU<:Union{Function, Matrix{Float64}}, TP<:Union{Function, Matrix{Float64}}}","page":"Developers","title":"CTModels.build_solution","text":"build_solution(\n    ocp::CTModels.Model,\n    T::Vector{Float64},\n    X::Union{Function, Matrix{Float64}},\n    U::Union{Function, Matrix{Float64}},\n    v::Vector{Float64},\n    P::Union{Function, Matrix{Float64}};\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    path_constraints,\n    path_constraints_dual,\n    boundary_constraints,\n    boundary_constraints_dual,\n    state_constraints_lb_dual,\n    state_constraints_ub_dual,\n    control_constraints_lb_dual,\n    control_constraints_ub_dual,\n    variable_constraints_lb_dual,\n    variable_constraints_ub_dual\n)\n\n\nBuild a solution from the optimal control problem, the time grid, the state, control, variable, and dual variables.\n\nArguments\n\nocp::Model: the optimal control problem.\nT::Vector{Float64}: the time grid.\nX::Matrix{Float64}: the state trajectory.\nU::Matrix{Float64}: the control trajectory.\nv::Vector{Float64}: the variable trajectory.\nP::Matrix{Float64}: the costate trajectory.\nobjective::Float64: the objective value.\niterations::Int: the number of iterations.\nconstraints_violation::Float64: the constraints violation.\nmessage::String: the message associated to the stopping criterion.\nstopping::Symbol: the stopping criterion.\nsuccess::Bool: the success status.\npath_constraints::Matrix{Float64}: the path constraints.\npath_constraints_dual::Matrix{Float64}: the dual of the path constraints.\nboundary_constraints::Vector{Float64}: the boundary constraints.\nboundary_constraints_dual::Vector{Float64}: the dual of the boundary constraints.\nstate_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the state constraints.\nstate_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the state constraints.\ncontrol_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the control constraints.\ncontrol_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the control constraints.\nvariable_constraints_lb_dual::Vector{Float64}: the lower bound dual of the variable constraints.\nvariable_constraints_ub_dual::Vector{Float64}: the upper bound dual of the variable constraints.\n\nReturns\n\nsol::Solution: the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.checkDim-Tuple{Any, Any}","page":"Developers","title":"CTModels.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.ControlModelSolution}","page":"Developers","title":"CTModels.components","text":"components(\n    model::CTModels.ControlModelSolution\n) -> Vector{String}\n\n\nGet the components names of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.ControlModel}","page":"Developers","title":"CTModels.components","text":"components(model::CTModels.ControlModel) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.EmptyVariableModel}","page":"Developers","title":"CTModels.components","text":"components(_::CTModels.EmptyVariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the empty variable model. Return an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.StateModelSolution}","page":"Developers","title":"CTModels.components","text":"components(\n    model::CTModels.StateModelSolution\n) -> Vector{String}\n\n\nGet the components names of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.StateModel}","page":"Developers","title":"CTModels.components","text":"components(model::CTModels.StateModel) -> Vector{String}\n\n\nGet the components names of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.VariableModelSolution}","page":"Developers","title":"CTModels.components","text":"components(\n    model::CTModels.VariableModelSolution\n) -> Vector{String}\n\n\nGet the components names of the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.VariableModel}","page":"Developers","title":"CTModels.components","text":"components(model::CTModels.VariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"Developers","title":"CTModels.constraint!","text":"constraint!(\n    ocp::CTModels.PreModel,\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a pre-model. See [__constraint!](@ref) for more details.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraint-Tuple{CTModels.Model, Symbol}","page":"Developers","title":"CTModels.constraint","text":"constraint(ocp::CTModels.Model, label::Symbol) -> Tuple\n\n\nGet a labelled constraint from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraints-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C}}, Tuple{C}} where C<:CTModels.AbstractConstraintsModel","page":"Developers","title":"CTModels.constraints","text":"constraints(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nGet the constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraints_violation-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.constraints_violation","text":"constraints_violation(sol::CTModels.Solution) -> Float64\n\n\nReturn the constraints violation of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Developers","title":"CTModels.control!","text":"control!(ocp::CTModels.PreModel, m::Int64)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol}\n)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\", [\"a\", \"b\"])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\njulia> control!(ocp, 2, \"v\", [:a, :b])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T}}, Tuple{T}} where T<:CTModels.AbstractControlModel","page":"Developers","title":"CTModels.control","text":"control(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nGet the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.control","text":"control(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_components-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.control_components","text":"control_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_components-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_components","text":"control_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}, Tuple{TC}} where TC","page":"Developers","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}\n) -> Any\n\n\nGet the control box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}}, Tuple{TC}} where TC<:Tuple","page":"Developers","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC<:Tuple}}\n) -> Any\n\n\nGet the box constraints on control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual}}, Tuple{CC_LB_Dual}} where CC_LB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual}}, Tuple{CC_UB_Dual}} where CC_UB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_dimension-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.control_dimension","text":"control_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_dimension-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_dimension","text":"control_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_discretized-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_discretized","text":"control_discretized(sol::CTModels.Solution) -> Any\n\n\nReturn the control values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> u  = control_discretized(sol)\njulia> u0 = u[1] # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.control_name","text":"control_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_name","text":"control_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.costate-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co<:Function","page":"Developers","title":"CTModels.costate","text":"costate(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.costate_discretized-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.costate_discretized","text":"costate_discretized(sol::CTModels.Solution) -> Any\n\n\nReturn the costate values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> p  = costate_discretized(sol)\njulia> p0 = p[1] # costate at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.BolzaObjectiveModel}","page":"Developers","title":"CTModels.criterion","text":"criterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.LagrangeObjectiveModel}","page":"Developers","title":"CTModels.criterion","text":"criterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.MayerObjectiveModel}","page":"Developers","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.criterion","text":"criterion(ocp::CTModels.Model) -> Symbol\n\n\nGet the type of criterion (:min or :max) from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.ctinterpolate-Tuple{Any, Any}","page":"Developers","title":"CTModels.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.definition!-Tuple{CTModels.PreModel, Expr}","page":"Developers","title":"CTModels.definition!","text":"definition!(ocp::CTModels.PreModel, definition::Expr)\n\n\nSet the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.definition-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.definition","text":"definition(ocp::CTModels.Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.definition-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.definition","text":"definition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_control_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of control box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_control_constraints_box-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_state_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of state box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_state_constraints_box-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.ControlModelSolution}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModelSolution) -> Int64\n\n\nGet the control dimension from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.ControlModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModel) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.EmptyVariableModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(_::CTModels.EmptyVariableModel) -> Int64\n\n\nGet the variable dimension from the empty variable model. Return 0.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.StateModelSolution}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModelSolution) -> Int64\n\n\nGet the dimension of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.StateModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModel) -> Int64\n\n\nGet the dimension of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.VariableModelSolution}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModelSolution) -> Int64\n\n\nGet the variable dimension from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.VariableModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModel) -> Int64\n\n\nGet the variable dimension from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dual_model-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM}}, Tuple{DM}} where DM<:CTModels.AbstractDualModel","page":"Developers","title":"CTModels.dual_model","text":"dual_model(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM<:CTModels.AbstractDualModel}\n) -> CTModels.AbstractDualModel\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Function}","page":"Developers","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, f::Function)\n\n\nSet the dynamics of the optimal control problem, in a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dynamics-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D}}, Tuple{D}} where D<:Function","page":"Developers","title":"CTModels.dynamics","text":"dynamics(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nGet the dynamics from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.export_ocp_solution-Tuple","page":"Developers","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(args...; format, kwargs...)\n\n\nExport a solution in JLD or JSON formats.\n\nExamples\n\njulia> CTModels.export_ocp_solution(sol; filename_prefix=\"solution\", format=:JSON)\njulia> CTModels.export_ocp_solution(sol; filename_prefix=\"solution\", format=:JLD)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.export_ocp_solution-Tuple{CTModels.JLD2Tag, Vararg{Any}}","page":"Developers","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(::CTModels.JLD2Tag, args...; kwargs...)\n\n\nExport a solution in JLD format.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.export_ocp_solution-Tuple{CTModels.JSON3Tag, Vararg{Any}}","page":"Developers","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(::CTModels.JSON3Tag, args...; kwargs...)\n\n\nExport a solution in JSON format.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF}}, Tuple{TF}} where TF<:CTModels.AbstractTimeModel","page":"Developers","title":"CTModels.final","text":"final(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Tuple{CTModels.AbstractModel, AbstractVector}","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.AbstractModel,\n    variable::AbstractVector\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Tuple{CTModels.AbstractModel}","page":"Developers","title":"CTModels.final_time","text":"final_time(ocp::CTModels.AbstractModel) -> Real\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the final time from the model, for a fixed final time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.final_time_name","text":"final_time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the final time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.final_time_name","text":"final_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the final time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time_name-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.formatData-Tuple{Any}","page":"Developers","title":"CTModels.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.formatTimeGrid-Tuple{Any}","page":"Developers","title":"CTModels.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_final_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_final_time-Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}","page":"Developers","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_initial_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_initial_time-Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}}","page":"Developers","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_final_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_free_final_time","text":"has_free_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_final_time-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_initial_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_initial_time-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.BolzaObjectiveModel\n) -> Bool\n\n\nCheck if the Bolza objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.MayerObjectiveModel}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.MayerObjectiveModel\n) -> Bool\n\n\nCheck if the Mayer objective model has a Lagrange function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.BolzaObjectiveModel) -> Bool\n\n\nCheck if the Bolza objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Mayer function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.MayerObjectiveModel}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.MayerObjectiveModel) -> Bool\n\n\nCheck if the Mayer objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.import_ocp_solution-Tuple","page":"Developers","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(args...; format, kwargs...)\n\n\nImport a solution from a JLD or JSON file.\n\nExamples\n\njulia> sol = CTModels.import_ocp_solution(ocp; filename_prefix=\"solution\", format=:JSON)\njulia> sol = CTModels.import_ocp_solution(ocp; filename_prefix=\"solution\", format=:JLD)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.import_ocp_solution-Tuple{CTModels.JLD2Tag, Vararg{Any}}","page":"Developers","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(::CTModels.JLD2Tag, args...; kwargs...)\n\n\nImport a solution from a JLD file.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.import_ocp_solution-Tuple{CTModels.JSON3Tag, Vararg{Any}}","page":"Developers","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(::CTModels.JSON3Tag, args...; kwargs...)\n\n\nImport a solution from a JLD file.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.index-Tuple{CTModels.FreeTimeModel}","page":"Developers","title":"CTModels.index","text":"index(model::CTModels.FreeTimeModel) -> Int64\n\n\nGet the index of the time variable from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.infos-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.infos","text":"infos(sol::CTModels.Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial-Union{Tuple{CTModels.TimesModel{TI}}, Tuple{TI}} where TI<:CTModels.AbstractTimeModel","page":"Developers","title":"CTModels.initial","text":"initial(\n    model::CTModels.TimesModel{TI<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{CTModels.Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the initial time from the model, for a fixed initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.initial_time_name","text":"initial_time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the initial time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.initial_time_name","text":"initial_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the initial time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time_name-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.is_empty_time_grid-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.is_empty_time_grid","text":"is_empty_time_grid(sol::CTModels.Solution) -> Bool\n\n\nCheck if the time grid is empty from the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.isaVectVect-Tuple{Any}","page":"Developers","title":"CTModels.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.isempty_constraints-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.isempty_constraints","text":"isempty_constraints(ocp::CTModels.Model) -> Bool\n\n\nReturn if the constraints from the model are not empty.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.iterations-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.iterations","text":"iterations(sol::CTModels.Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.BolzaObjectiveModel{<:Function, L}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.LagrangeObjectiveModel{L}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L}}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L}}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.matrix2vec","page":"Developers","title":"CTModels.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.BolzaObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.MayerObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.message-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.message","text":"message(sol::CTModels.Solution) -> String\n\n\nReturn the message associated to the stopping criterion of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.ControlModelSolution}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.ControlModelSolution) -> String\n\n\nGet the name of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.ControlModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.ControlModel) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.EmptyVariableModel}","page":"Developers","title":"CTModels.name","text":"name(_::CTModels.EmptyVariableModel) -> String\n\n\nGet the variable name from the empty variable model. Return an empty string.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.FixedTimeModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.FixedTimeModel) -> String\n\n\nGet the name of the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.FreeTimeModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.FreeTimeModel) -> String\n\n\nGet the name of the time from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.StateModelSolution}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.StateModelSolution) -> String\n\n\nGet the name of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.StateModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.StateModel) -> String\n\n\nGet the name of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.VariableModelSolution}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.VariableModelSolution) -> String\n\n\nGet the variable name from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.VariableModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.VariableModel) -> String\n\n\nGet the variable name from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.objective!","page":"Developers","title":"CTModels.objective!","text":"objective!(ocp::CTModels.PreModel; ...)\nobjective!(\n    ocp::CTModels.PreModel,\n    criterion::Symbol;\n    mayer,\n    lagrange\n)\n\n\nSet the objective of the optimal control problem.\n\nArguments\n\nocp::PreModel: the optimal control problem.\ncriterion::Symbol: the type of criterion. Either :min or :max. Default is :min.\nmayer::Union{Function, Nothing}: the Mayer function (inplace). Default is nothing.\nlagrange::Union{Function, Nothing}: the Lagrange function (inplace). Default is nothing.\n\nnote: Note\nThe state, control and variable must be set before the objective.\nThe objective must not be set before.\nAt least one of the two functions must be given. Please provide a Mayer or a Lagrange function.\n\nExamples\n\n```@example julia> function mayer(x0, xf, v)            return x0[1] + xf[1] + v[1]        end juila> function lagrange(t, x, u, v)            return x[1] + u[1] + v[1]        end julia> objective!(ocp, :min, mayer=mayer, lagrange=lagrange)\n\n\n\n\n\n","category":"function"},{"location":"dev.html#CTModels.objective-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:CTModels.AbstractObjectiveModel","page":"Developers","title":"CTModels.objective","text":"objective(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nGet the objective from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.objective-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:Real","page":"Developers","title":"CTModels.objective","text":"objective(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.path_constraints","text":"path_constraints(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints-Union{Tuple{CTModels.DualModel{PC}}, Tuple{PC}} where PC<:Union{Nothing, Function}","page":"Developers","title":"CTModels.path_constraints","text":"path_constraints(\n    model::CTModels.DualModel{PC<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the dual of the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, PC_Dual}}, Tuple{PC_Dual}} where PC_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, PC_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{TP}}, Tuple{TP}} where TP","page":"Developers","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    model::CTModels.ConstraintsModel{TP}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP}}}, Tuple{TP}} where TP<:Tuple","page":"Developers","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP<:Tuple}}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Developers","title":"CTModels.state!","text":"state!(ocp::CTModels.PreModel, n::Int64)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol}\n)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\", [\"u\", \"v\"])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\njulia> state!(ocp, 2, \"y\", [:u, :v])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, T}}, Tuple{T}} where T<:CTModels.AbstractStateModel","page":"Developers","title":"CTModels.state","text":"state(\n    ocp::CTModels.Model{<:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nGet the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.state","text":"state(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_components-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.state_components","text":"state_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_components-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_components","text":"state_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}, Tuple{TS}} where TS","page":"Developers","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}\n) -> Any\n\n\nGet the state box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}}, Tuple{TS}} where TS<:Tuple","page":"Developers","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS<:Tuple}}\n) -> Any\n\n\nGet the box constraints on state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual}}, Tuple{SC_LB_Dual}} where SC_LB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual}}, Tuple{SC_UB_Dual}} where SC_UB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_dimension-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the state dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_dimension-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_dimension","text":"state_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_discretized-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_discretized","text":"state_discretized(sol::CTModels.Solution) -> Any\n\n\nReturn the state values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> x  = state_discretized(sol)\njulia> x0 = x[1] # state at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.state_name","text":"state_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_name","text":"state_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.stopping-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.stopping","text":"stopping(sol::CTModels.Solution) -> Symbol\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.success-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.success","text":"success(sol::CTModels.Solution) -> Bool\n\n\nReturn the success status of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time!-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.time!","text":"time!(ocp::CTModels.PreModel; t0, tf, ind0, indf, time_name)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then, one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time-Union{Tuple{CTModels.FixedTimeModel{T}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.time","text":"time(model::CTModels.FixedTimeModel{T<:Real}) -> Real\n\n\nGet the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time-Union{Tuple{T}, Tuple{CTModels.FreeTimeModel, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.time","text":"time(\n    model::CTModels.FreeTimeModel,\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the time from the free time model.\n\nExceptions\n\nIf the index of the time variable is not in [1, length(variable)], throw an error.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_grid-Union{Tuple{CTModels.Solution{<:CTModels.TimeGridModel{T}}}, Tuple{T}} where T<:Union{StepRangeLen, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.time_grid","text":"time_grid(\n    sol::CTModels.Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.time_name","text":"time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.time_name","text":"time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the time component of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_name-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.times-Union{Tuple{CTModels.Model{T}}, Tuple{T}} where T<:CTModels.TimesModel","page":"Developers","title":"CTModels.times","text":"times(\n    ocp::CTModels.Model{T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nGet the times from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.value-Union{Tuple{CTModels.ControlModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.value","text":"value(\n    model::CTModels.ControlModelSolution{TS<:Function}\n) -> Function\n\n\nGet the control function value from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.value-Union{Tuple{CTModels.StateModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.value","text":"value(\n    model::CTModels.StateModelSolution{TS<:Function}\n) -> Function\n\n\nGet the state function from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.value-Union{Tuple{CTModels.VariableModelSolution{TS}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.value","text":"value(\n    model::CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nGet the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Developers","title":"CTModels.variable!","text":"variable!(ocp::CTModels.PreModel, q::Int64)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol}\n)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T}}, Tuple{T}} where T<:CTModels.AbstractVariableModel","page":"Developers","title":"CTModels.variable","text":"variable(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nGet the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.variable","text":"variable(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_components-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.variable_components","text":"variable_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_components-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_components","text":"variable_components(\n    sol::CTModels.Solution\n) -> Vector{String}\n\n\nReturn the names of the components of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}, Tuple{TV}} where TV","page":"Developers","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}\n) -> Any\n\n\nGet the variable box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}}, Tuple{TV}} where TV<:Tuple","page":"Developers","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV<:Tuple}}\n) -> Any\n\n\nGet the box constraints on variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual}}, Tuple{VC_LB_Dual}} where VC_LB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual}}, Tuple{VC_UB_Dual}} where VC_UB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_dimension-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the variable dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_dimension-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_dimension","text":"variable_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.variable_name","text":"variable_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_name","text":"variable_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#RecipesBase.plot!-Tuple{RecipesBase.AbstractPlot, CTModels.AbstractSolution}","page":"Developers","title":"RecipesBase.plot!","text":"plot!(\n    p::RecipesBase.AbstractPlot,\n    sol::CTModels.AbstractSolution;\n    kwargs...\n)\n\n\nPlot a solution on an existing plot.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#RecipesBase.plot-Tuple{CTModels.AbstractSolution}","page":"Developers","title":"RecipesBase.plot","text":"plot(sol::CTModels.AbstractSolution; kwargs...)\n\n\nPlot a solution.\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTModels.jl","page":"Introduction","title":"CTModels.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTModels.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"}]
}
