var documenterSearchIndex = {"docs":
[{"location":"dev.html#Private-functions","page":"Developers","title":"Private functions","text":"","category":"section"},{"location":"dev.html#CTModels","page":"Developers","title":"CTModels","text":"","category":"section"},{"location":"dev.html#CTModels.CTModels","page":"Developers","title":"CTModels.CTModels","text":"CTModels module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nInterpolations\nMLStyle\nParameters\nPrettyTables\n\nList of all the exported names:\n\nplot\nplot!\n\n\n\n\n\n","category":"module"},{"location":"dev.html#Index","page":"Developers","title":"Index","text":"","category":"section"},{"location":"dev.html","page":"Developers","title":"Developers","text":"Pages   = [\"dev.md\"]\nModules = [CTModels]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"dev.html#Documentation","page":"Developers","title":"Documentation","text":"","category":"section"},{"location":"dev.html#CTModels.TimesDisc","page":"Developers","title":"CTModels.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractConstraintsModel","page":"Developers","title":"CTModels.AbstractConstraintsModel","text":"abstract type AbstractConstraintsModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractControlModel","page":"Developers","title":"CTModels.AbstractControlModel","text":"abstract type AbstractControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractDualModel","page":"Developers","title":"CTModels.AbstractDualModel","text":"abstract type AbstractDualModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractModel","page":"Developers","title":"CTModels.AbstractModel","text":"abstract type AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractObjectiveModel","page":"Developers","title":"CTModels.AbstractObjectiveModel","text":"abstract type AbstractObjectiveModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractSolution","page":"Developers","title":"CTModels.AbstractSolution","text":"abstract type AbstractSolution\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractSolverInfos","page":"Developers","title":"CTModels.AbstractSolverInfos","text":"abstract type AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractStateModel","page":"Developers","title":"CTModels.AbstractStateModel","text":"abstract type AbstractStateModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTag","page":"Developers","title":"CTModels.AbstractTag","text":"abstract type AbstractTag\n\nAbstract type for export/import functions, used to choose between JSON or JLD extensions.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTimeGridModel","page":"Developers","title":"CTModels.AbstractTimeGridModel","text":"abstract type AbstractTimeGridModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTimeModel","page":"Developers","title":"CTModels.AbstractTimeModel","text":"abstract type AbstractTimeModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractTimesModel","page":"Developers","title":"CTModels.AbstractTimesModel","text":"abstract type AbstractTimesModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.AbstractVariableModel","page":"Developers","title":"CTModels.AbstractVariableModel","text":"abstract type AbstractVariableModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Autonomous","page":"Developers","title":"CTModels.Autonomous","text":"abstract type Autonomous <: CTModels.TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.BolzaObjectiveModel","page":"Developers","title":"CTModels.BolzaObjectiveModel","text":"struct BolzaObjectiveModel{TM<:Function, TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ConstraintsDictType","page":"Developers","title":"CTModels.ConstraintsDictType","text":"Type alias for a dictionnary of constraints. This is used to store constraints before building the model.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: ConstraintsModel, PreModel and Model.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ConstraintsModel","page":"Developers","title":"CTModels.ConstraintsModel","text":"struct ConstraintsModel{TP<:Tuple, TB<:Tuple, TS<:Tuple, TC<:Tuple, TV<:Tuple} <: CTModels.AbstractConstraintsModel\n\nFields\n\npath_nl::Tuple\nboundary_nl::Tuple\nstate_box::Tuple\ncontrol_box::Tuple\nvariable_box::Tuple\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ControlModel","page":"Developers","title":"CTModels.ControlModel","text":"struct ControlModel <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ControlModelSolution","page":"Developers","title":"CTModels.ControlModelSolution","text":"struct ControlModelSolution{TS<:Function} <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Dimension","page":"Developers","title":"CTModels.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.DualModel","page":"Developers","title":"CTModels.DualModel","text":"struct DualModel{PC_Dual<:Union{Nothing, Function}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}} <: CTModels.AbstractDualModel\n\nFields\n\npath_constraints_dual::Union{Nothing, Function}\nboundary_constraints_dual::Union{Nothing, AbstractVector{<:Real}}\nstate_constraints_lb_dual::Union{Nothing, Function}\nstate_constraints_ub_dual::Union{Nothing, Function}\ncontrol_constraints_lb_dual::Union{Nothing, Function}\ncontrol_constraints_ub_dual::Union{Nothing, Function}\nvariable_constraints_lb_dual::Union{Nothing, AbstractVector{<:Real}}\nvariable_constraints_ub_dual::Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.EmptyTimeGridModel","page":"Developers","title":"CTModels.EmptyTimeGridModel","text":"struct EmptyTimeGridModel <: CTModels.AbstractTimeGridModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.EmptyVariableModel","page":"Developers","title":"CTModels.EmptyVariableModel","text":"struct EmptyVariableModel <: CTModels.AbstractVariableModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.FixedTimeModel","page":"Developers","title":"CTModels.FixedTimeModel","text":"struct FixedTimeModel{T<:Real} <: CTModels.AbstractTimeModel\n\nFields\n\ntime::Real\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.FreeTimeModel","page":"Developers","title":"CTModels.FreeTimeModel","text":"struct FreeTimeModel <: CTModels.AbstractTimeModel\n\nFields\n\nindex::Int64\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Init","page":"Developers","title":"CTModels.Init","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nInit(): default initialization\nInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nInit(sol): from existing solution\n\nExamples\n\njulia> init = Init()\njulia> init = Init(state=[0.1, 0.2], control=0.3)\njulia> init = Init(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = Init(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = Init(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = Init(sol)\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.JLD2Tag","page":"Developers","title":"CTModels.JLD2Tag","text":"struct JLD2Tag <: CTModels.AbstractTag\n\nJLD tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.JSON3Tag","page":"Developers","title":"CTModels.JSON3Tag","text":"struct JSON3Tag <: CTModels.AbstractTag\n\nJSON tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.LagrangeObjectiveModel","page":"Developers","title":"CTModels.LagrangeObjectiveModel","text":"struct LagrangeObjectiveModel{TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.MayerObjectiveModel","page":"Developers","title":"CTModels.MayerObjectiveModel","text":"struct MayerObjectiveModel{TM<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Model","page":"Developers","title":"CTModels.Model","text":"struct Model{TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.NonAutonomous","page":"Developers","title":"CTModels.NonAutonomous","text":"abstract type NonAutonomous <: CTModels.TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.PreModel","page":"Developers","title":"CTModels.PreModel","text":"mutable struct PreModel <: CTModels.AbstractModel\n\nFields\n\ntimes::Union{Nothing, CTModels.AbstractTimesModel}: Default: nothing\nstate::Union{Nothing, CTModels.AbstractStateModel}: Default: nothing\ncontrol::Union{Nothing, CTModels.AbstractControlModel}: Default: nothing\nvariable::CTModels.AbstractVariableModel: Default: EmptyVariableModel()\ndynamics::Union{Nothing, Function, Vector{<:Tuple{var\"#s52\", var\"#s53\"} where {var\"#s52\"<:(AbstractRange{<:Int64}), var\"#s53\"<:Function}}}: Default: nothing\nobjective::Union{Nothing, CTModels.AbstractObjectiveModel}: Default: nothing\nconstraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}: Default: ConstraintsDictType()\ndefinition::Union{Nothing, Expr}: Default: nothing\nautonomous::Union{Nothing, Bool}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Solution","page":"Developers","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos, ModelType<:CTModels.AbstractModel} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\nmodel::CTModels.AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.SolverInfos","page":"Developers","title":"CTModels.SolverInfos","text":"struct SolverInfos{TI<:Dict{Symbol, Any}} <: CTModels.AbstractSolverInfos\n\nFields\n\niterations::Int64\nstopping::Symbol\nmessage::String\nsuccess::Bool\nconstraints_violation::Float64\ninfos::Dict{Symbol, Any}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.StateModel","page":"Developers","title":"CTModels.StateModel","text":"struct StateModel <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.StateModelSolution","page":"Developers","title":"CTModels.StateModelSolution","text":"struct StateModelSolution{TS<:Function} <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Time","page":"Developers","title":"CTModels.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.TimeDependence","page":"Developers","title":"CTModels.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.TimeGridModel","page":"Developers","title":"CTModels.TimeGridModel","text":"struct TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}} <: CTModels.AbstractTimeGridModel\n\nFields\n\nvalue::Union{StepRangeLen, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.Times","page":"Developers","title":"CTModels.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.TimesModel","page":"Developers","title":"CTModels.TimesModel","text":"struct TimesModel{TI<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel} <: CTModels.AbstractTimesModel\n\nFields\n\ninitial::CTModels.AbstractTimeModel\nfinal::CTModels.AbstractTimeModel\ntime_name::String\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.VariableModel","page":"Developers","title":"CTModels.VariableModel","text":"struct VariableModel <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.VariableModelSolution","page":"Developers","title":"CTModels.VariableModelSolution","text":"struct VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}} <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ctNumber","page":"Developers","title":"CTModels.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTModels.ctVector","page":"Developers","title":"CTModels.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = AbstractVector{<:ctNumber}\n\nSee also: ctNumber.\n\n\n\n\n\n","category":"type"},{"location":"dev.html#Base.isempty-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"Base.isempty","text":"isempty(model::CTModels.ConstraintsModel) -> Bool\n\n\nReturn if the constraints model is empty or not.\n\nArguments\n\nmodel: The constraints model to check for emptiness.\n\nReturns\n\nBool: Returns true if the model has no constraints, false otherwise.\n\nExample\n\n# Example of checking if a constraints model is empty\njulia> model = ConstraintsModel(...)\njulia> isempty(model)  # Returns true if there are no constraints\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Model}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.Model\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.PreModel}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.PreModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Solution}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::CTModels.Solution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#Base.show_default-Tuple{IO, CTModels.PreModel}","page":"Developers","title":"Base.show_default","text":"show_default(io::IO, ocp::CTModels.PreModel)\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__build_dynamics_from_parts-Tuple{Vector{<:Tuple{var\"#s53\", var\"#s52\"} where {var\"#s53\"<:(AbstractRange{<:Int64}), var\"#s52\"<:Function}}}","page":"Developers","title":"CTModels.__build_dynamics_from_parts","text":"__build_dynamics_from_parts(\n    parts::Vector{<:Tuple{var\"#s53\", var\"#s52\"} where {var\"#s53\"<:(AbstractRange{<:Int64}), var\"#s52\"<:Function}}\n) -> CTModels.var\"#dyn!#64\"{Vector{var\"#s54\"}} where var\"#s54\"<:(Tuple{var\"#s53\", var\"#s52\"} where {var\"#s53\"<:(AbstractRange{<:Int64}), var\"#s52\"<:Function})\n\n\nBuild a combined dynamics function from multiple parts.\n\nThis function constructs an in-place dynamics function dyn! by composing several sub-functions, each responsible for updating a specific segment of the output vector.\n\nArguments\n\nparts::Vector{<:Tuple{<:AbstractRange{<:Int}, <:Function}}:  A vector of tuples, where each tuple contains:\nA range specifying the indices in the output vector val that the corresponding function updates.\nA function f with the signature (output_segment, t, x, u, v), which updates the slice of val indicated by the range.\n\nReturns\n\ndyn!: A function with signature (val, t, x, u, v) that updates the full output vector val in-place by applying each part function to its assigned segment.\n\nDetails\n\nThe returned dyn! function calls each part function with a view of val restricted to the assigned range. This avoids unnecessary copying and allows efficient updates of sub-vectors.\nEach part function is expected to modify its output segment in-place.\n\nExample\n\n# Define two sub-dynamics functions\njulia> f1(out, t, x, u, v) = out .= x[1:2] .+ u[1:2]\njulia> f2(out, t, x, u, v) = out .= x[3] * v\n\n# Combine them into one dynamics function affecting different parts of the output vector\njulia> parts = [(1:2, f1), (3:3, f2)]\njulia> dyn! = __build_dynamics_from_parts(parts)\n\nval = zeros(3)\njulia> dyn!(val, 0.0, [1.0, 2.0, 3.0], [0.5, 0.5], 2.0)\njulia> println(val)  # prints [1.5, 2.5, 6.0]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__constraint!-Tuple{OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}, Symbol, Int64, Int64, Int64}","page":"Developers","title":"CTModels.__constraint!","text":"__constraint!(\n    ocp_constraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}},\n    type::Symbol,\n    n::Int64,\n    m::Int64,\n    q::Int64;\n    rg,\n    f,\n    lb,\n    ub,\n    label,\n    codim_f\n)\n\n\nAdd a constraint to a dictionary of constraints.\n\nArguments\n\nocp_constraints: The dictionary of constraints to which the constraint will be added.\ntype: The type of the constraint. It can be :state, :control, :variable, :boundary, or :path.\nn: The dimension of the state.\nm: The dimension of the control.\nq: The dimension of the variable.\nrg: The range of the constraint. It can be an integer or a range of integers.\nf: The function that defines the constraint. It must return a vector of the same dimension as the constraint.\nlb: The lower bound of the constraint. It can be a number or a vector.\nub: The upper bound of the constraint. It can be a number or a vector.\nlabel: The label of the constraint. It must be unique in the dictionary of constraints.\n\nRequirements\n\nThe constraint must not be set before.\nThe lower bound lb and the upper bound ub cannot be both nothing.\nThe lower bound lb and the upper bound ub must have the same length, if both provided.\n\nIf rg and f are not provided then, \n\ntype must be :state, :control, or :variable.\nlb and ub must be of dimension n, m, or q respectively, when provided.\n\nIf rg is provided, then:\n\nf must not be provided.\ntype must be :state, :control, or :variable.\nrg must be a range of integers, and must be contained in 1:n, 1:m, or 1:q respectively.\n\nIf f is provided, then:\n\nrg must not be provided.\ntype must be :boundary or :path.\nf must be a function that returns a vector of the same dimension as the constraint.\nlb and ub must be of the same dimension as the output of f, when provided.\n\nExample\n\n# Example of adding a state constraint\njulia> ocp_constraints = Dict()\n__constraint!(ocp_constraints, :state, 3, 2, 1, lb=[0.0], ub=[1.0], label=:my_constraint)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__constraint_label-Tuple{}","page":"Developers","title":"CTModels.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__constraints-Tuple{}","page":"Developers","title":"CTModels.__constraints","text":"__constraints()\n\n\nUsed to set the default value for the constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__control_components-Tuple{Int64, String}","page":"Developers","title":"CTModels.__control_components","text":"__control_components(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__control_name-Tuple{}","page":"Developers","title":"CTModels.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__criterion_type-Tuple{}","page":"Developers","title":"CTModels.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__filename_export_import-Tuple{}","page":"Developers","title":"CTModels.__filename_export_import","text":"__filename_export_import() -> String\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__format-Tuple{}","page":"Developers","title":"CTModels.__format","text":"__format() -> Symbol\n\n\nUsed to set the default value of the format of the file to be used for export and import.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_autonomous_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_autonomous_set","text":"__is_autonomous_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_complete-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_complete","text":"__is_complete(ocp::CTModels.PreModel) -> Bool\n\n\nReturn true if the PreModel can be built into a Model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_consistent-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_consistent","text":"__is_consistent(ocp::CTModels.PreModel) -> Bool\n\n\nReturn true if all the required fields are set in the PreModel.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_control_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_control_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_definition_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_definition_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_dynamics_complete-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_dynamics_complete","text":"__is_dynamics_complete(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_dynamics_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_dynamics_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_empty-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_empty","text":"__is_empty(ocp::CTModels.PreModel) -> Bool\n\n\nReturn true if nothing has been set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_objective_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_objective_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_set-Tuple{Any}","page":"Developers","title":"CTModels.__is_set","text":"__is_set(x) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_state_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_state_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_times_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_times_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_variable_empty-Tuple{Any}","page":"Developers","title":"CTModels.__is_variable_empty","text":"__is_variable_empty(v) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_variable_set-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__is_variable_set-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__matrix_dimension_storage-Tuple{}","page":"Developers","title":"CTModels.__matrix_dimension_storage","text":"__matrix_dimension_storage() -> Int64\n\n\nUsed to set the default value of the storage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__state_components-Tuple{Int64, String}","page":"Developers","title":"CTModels.__state_components","text":"__state_components(n::Int64, name::String) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__state_name-Tuple{}","page":"Developers","title":"CTModels.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__time_name-Tuple{}","page":"Developers","title":"CTModels.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__variable_components-Tuple{Int64, String}","page":"Developers","title":"CTModels.__variable_components","text":"__variable_components(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.__variable_name-Tuple{Int64}","page":"Developers","title":"CTModels.__variable_name","text":"__variable_name(q::Int64) -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.append_box_constraints!-NTuple{8, Any}","page":"Developers","title":"CTModels.append_box_constraints!","text":"append_box_constraints!(\n    inds,\n    lbs,\n    ubs,\n    labels,\n    rg,\n    lb,\n    ub,\n    label\n)\n\n\nAppends box constraint data to the provided vectors.\n\nArguments\n\ninds::Vector{Int}: Vector of indices to which the range rg will be appended.\nlbs::Vector{<:Real}: Vector of lower bounds to which lb will be appended.\nubs::Vector{<:Real}: Vector of upper bounds to which ub will be appended.\nlabels::Vector{String}: Vector of labels to which the label will be repeated and appended.\nrg::AbstractVector{Int}: Index range corresponding to the constraint variables.\nlb::AbstractVector{<:Real}: Lower bounds associated with rg.\nub::AbstractVector{<:Real}: Upper bounds associated with rg.\nlabel::String: Label describing the constraint block (e.g., \"state\", \"control\").\n\nNotes\n\nAll input vectors (rg, lb, ub) must have the same length.\nThe function modifies the inds, lbs, ubs, and labels vectors in-place.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual of the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, BC_Dual}}, Tuple{BC_Dual}} where BC_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual vector associated with the boundary constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for boundary constraints.\n\nReturns\n\nA vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, TB}}, Tuple{TB}} where TB","page":"Developers","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    model::CTModels.ConstraintsModel{<:Tuple, TB}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the boundary constraints.\n\nReturns\n\nThe nonlinear boundary constraints.\n\nExample\n\n# Example of retrieving nonlinear boundary constraints\njulia> model = ConstraintsModel(...)\njulia> boundary_constraints = boundary_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB}}}, Tuple{TB}} where TB<:Tuple","page":"Developers","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB<:Tuple}}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Any, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTModels.var\"#25#26\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Function, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTModels.var\"#27#28\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTModels.var\"#25#26\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"Developers","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTModels.var\"#29#31\", CTModels.var\"#30#32\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.buildVectorInit-Tuple{Any, Any}","page":"Developers","title":"CTModels.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.build_constraints-Tuple{OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}}","page":"Developers","title":"CTModels.build_constraints","text":"build_constraints(\n    constraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n) -> CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}}\n\n\nConstructs a ConstraintsModel from a dictionary of constraints.\n\nThis function processes a dictionary where each entry defines a constraint with its type, function or index range, lower and upper bounds, and label. It categorizes constraints into path, boundary, state, control, and variable constraints, assembling them into a structured ConstraintsModel.\n\nArguments\n\nconstraints::ConstraintsDictType: A dictionary mapping constraint labels to tuples of the form (type, function_or_range, lower_bound, upper_bound).\n\nReturns\n\nConstraintsModel: A structured model encapsulating all provided constraints.\n\nExample\n\nconstraints = OrderedDict(\n    :c1 => (:path, f1, [0.0], [1.0]),\n    :c2 => (:state, 1:2, [-1.0, -1.0], [1.0, 1.0])\n)\nmodel = build_constraints(constraints)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.build_model-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.build_model","text":"build_model(\n    pre_ocp::CTModels.PreModel\n) -> CTModels.Model{TD, var\"#s182\", var\"#s1821\", var\"#s1822\", var\"#s1823\", var\"#s1824\", var\"#s1825\", CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}}} where {TD<:CTModels.TimeDependence, var\"#s182\"<:CTModels.AbstractTimesModel, var\"#s1821\"<:CTModels.AbstractStateModel, var\"#s1822\"<:CTModels.AbstractControlModel, var\"#s1823\"<:CTModels.AbstractVariableModel, var\"#s1824\"<:Function, var\"#s1825\"<:CTModels.AbstractObjectiveModel, TP<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}}\n\n\nBuilds a concrete Model from a PreModel.\n\nThis function finalizes a pre-defined optimal control problem (PreModel) by verifying that all necessary components (times, state, control, dynamics) are set. It then constructs a Model instance, incorporating optional components like objective and constraints if they are defined.\n\nArguments\n\npre_ocp::PreModel: The pre-defined optimal control problem to be finalized.\n\nReturns\n\nModel: A fully constructed model ready for solving.\n\nExample\n\npre_ocp = PreModel()\ntimes!(pre_ocp, 0.0, 1.0, 100)\nstate!(pre_ocp, 2, \"x\", [\"x1\", \"x2\"])\ncontrol!(pre_ocp, 1, \"u\", [\"u1\"])\ndynamics!(pre_ocp, (dx, t, x, u, v) -> dx .= x + u)\nmodel = build_model(pre_ocp)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.build_solution-Union{Tuple{TPCD}, Tuple{TP}, Tuple{TU}, Tuple{TX}, Tuple{CTModels.Model, Vector{Float64}, TX, TU, Vector{Float64}, TP}} where {TX<:Union{Function, Matrix{Float64}}, TU<:Union{Function, Matrix{Float64}}, TP<:Union{Function, Matrix{Float64}}, TPCD<:Union{Nothing, Function, Matrix{Float64}}}","page":"Developers","title":"CTModels.build_solution","text":"build_solution(\n    ocp::CTModels.Model,\n    T::Vector{Float64},\n    X::Union{Function, Matrix{Float64}},\n    U::Union{Function, Matrix{Float64}},\n    v::Vector{Float64},\n    P::Union{Function, Matrix{Float64}};\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    path_constraints_dual,\n    boundary_constraints_dual,\n    state_constraints_lb_dual,\n    state_constraints_ub_dual,\n    control_constraints_lb_dual,\n    control_constraints_ub_dual,\n    variable_constraints_lb_dual,\n    variable_constraints_ub_dual\n)\n\n\nBuild a solution from the optimal control problem, the time grid, the state, control, variable, and dual variables.\n\nArguments\n\nocp::Model: the optimal control problem.\nT::Vector{Float64}: the time grid.\nX::Matrix{Float64}: the state trajectory.\nU::Matrix{Float64}: the control trajectory.\nv::Vector{Float64}: the variable trajectory.\nP::Matrix{Float64}: the costate trajectory.\nobjective::Float64: the objective value.\niterations::Int: the number of iterations.\nconstraints_violation::Float64: the constraints violation.\nmessage::String: the message associated to the stopping criterion.\nstopping::Symbol: the stopping criterion.\nsuccess::Bool: the success status.\npath_constraints_dual::Matrix{Float64}: the dual of the path constraints.\nboundary_constraints_dual::Vector{Float64}: the dual of the boundary constraints.\nstate_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the state constraints.\nstate_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the state constraints.\ncontrol_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the control constraints.\ncontrol_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the control constraints.\nvariable_constraints_lb_dual::Vector{Float64}: the lower bound dual of the variable constraints.\nvariable_constraints_ub_dual::Vector{Float64}: the upper bound dual of the variable constraints.\n\nReturns\n\nsol::Solution: the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.checkDim-Tuple{Any, Any}","page":"Developers","title":"CTModels.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.ControlModelSolution}","page":"Developers","title":"CTModels.components","text":"components(\n    model::CTModels.ControlModelSolution\n) -> Vector{String}\n\n\nGet the names of the control components from the solution.\n\nArguments\n\nmodel::ControlModelSolution: The control model solution.\n\nReturns\n\nVector{String}: A list of control component names.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.ControlModel}","page":"Developers","title":"CTModels.components","text":"components(model::CTModels.ControlModel) -> Vector{String}\n\n\nGet the names of the control components.\n\nArguments\n\nmodel::ControlModel: The control model.\n\nReturns\n\nVector{String}: A list of control component names.\n\nExample\n\njulia> components(controlmodel)\n[\"u₁\", \"u₂\"]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.EmptyVariableModel}","page":"Developers","title":"CTModels.components","text":"components(_::CTModels.EmptyVariableModel) -> Vector{String}\n\n\nReturn an empty vector since there are no variable components defined.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.StateModelSolution}","page":"Developers","title":"CTModels.components","text":"components(\n    model::CTModels.StateModelSolution\n) -> Vector{String}\n\n\nGet the components names of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.StateModel}","page":"Developers","title":"CTModels.components","text":"components(model::CTModels.StateModel) -> Vector{String}\n\n\nGet the components names of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.VariableModelSolution}","page":"Developers","title":"CTModels.components","text":"components(\n    model::CTModels.VariableModelSolution\n) -> Vector{String}\n\n\nReturn the names of the components from the variable solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.components-Tuple{CTModels.VariableModel}","page":"Developers","title":"CTModels.components","text":"components(model::CTModels.VariableModel) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"Developers","title":"CTModels.constraint!","text":"constraint!(\n    ocp::CTModels.PreModel,\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label,\n    codim_f\n)\n\n\nAdd a constraint to a pre-model. See __constraint! for more details.\n\nArguments\n\nocp: The pre-model to which the constraint will be added.\ntype: The type of the constraint. It can be :state, :control, :variable, :boundary, or :path.\nrg: The range of the constraint. It can be an integer or a range of integers.\nf: The function that defines the constraint. It must return a vector of the same dimension as the constraint.\nlb: The lower bound of the constraint. It can be a number or a vector.\nub: The upper bound of the constraint. It can be a number or a vector.\nlabel: The label of the constraint. It must be unique in the pre-model.\n\nExample\n\n# Example of adding a control constraint to a pre-model\njulia> ocp = PreModel()\njulia> constraint!(ocp, :control, rg=1:2, lb=[0.0], ub=[1.0], label=:control_constraint)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraint-Tuple{CTModels.Model, Symbol}","page":"Developers","title":"CTModels.constraint","text":"constraint(\n    model::CTModels.Model,\n    label::Symbol\n) -> Tuple{Symbol, Any, Any, Any}\n\n\nGet a labelled constraint from the model. Returns a tuple of the form (type, f, lb, ub) where type is the type of the constraint, f is the function of the constraint, lb is the lower bound of the constraint and ub is the upper bound of the constraint. \n\nThe function returns an exception if the label is not found in the model.\n\nArguments\n\nmodel: The model from which to retrieve the constraint.\nlabel: The label of the constraint to retrieve.\n\nReturns\n\nTuple: A tuple containing the type, function, lower bound, and upper bound of the constraint.\n\nExample\n\njulia> # Example of getting a labelled constraint from the model\njulia> model = Model(...)\njulia> constraint_info = constraint(model, :my_constraint)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraints-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C}}, Tuple{C}} where C<:CTModels.AbstractConstraintsModel","page":"Developers","title":"CTModels.constraints","text":"constraints(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nGet the constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.constraints_violation-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.constraints_violation","text":"constraints_violation(sol::CTModels.Solution) -> Float64\n\n\nReturn the constraints violation of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Developers","title":"CTModels.control!","text":"control!(ocp::CTModels.PreModel, m::Int64)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol}\n)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the control input for a given optimal control problem model.\n\nThis function sets the control dimension and optionally allows specifying the control name and the names of its components.\n\nnote: Note\nThis function should be called only once per model. Calling it again will raise an error.\n\nArguments\n\nocp::PreModel: The model to which the control will be added.\nm::Dimension: The control input dimension (must be greater than 0).\nname::Union{String,Symbol} (optional): The name of the control variable (default: \"u\").\ncomponents_names::Vector{<:Union{String,Symbol}} (optional): Names of the control components (default: automatically generated).\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_components(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_components(ocp)\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\", [\"a\", \"b\"])\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, T}}, Tuple{T}} where T<:CTModels.AbstractControlModel","page":"Developers","title":"CTModels.control","text":"control(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nGet the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.control","text":"control(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_components-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.control_components","text":"control_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_components-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_components","text":"control_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}, Tuple{TC}} where TC","page":"Developers","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}\n) -> Any\n\n\nGet the control box constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the control box constraints.\n\nReturns\n\nThe control box constraints.\n\nExample\n\n# Example of retrieving control box constraints\njulia> model = ConstraintsModel(...)\njulia> control_constraints = control_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}}, Tuple{TC}} where TC<:Tuple","page":"Developers","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC<:Tuple}}\n) -> Any\n\n\nGet the box constraints on control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual}}, Tuple{CC_LB_Dual}} where CC_LB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the lower bounds of control constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for control lower bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual}}, Tuple{CC_UB_Dual}} where CC_UB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the upper bounds of control constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for control upper bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_dimension-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.control_dimension","text":"control_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_dimension-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_dimension","text":"control_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.control_name","text":"control_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.control_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.control_name","text":"control_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.costate-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co<:Function","page":"Developers","title":"CTModels.costate","text":"costate(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.BolzaObjectiveModel}","page":"Developers","title":"CTModels.criterion","text":"criterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.LagrangeObjectiveModel}","page":"Developers","title":"CTModels.criterion","text":"criterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.MayerObjectiveModel}","page":"Developers","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.criterion-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.criterion","text":"criterion(ocp::CTModels.Model) -> Symbol\n\n\nGet the type of criterion (:min or :max) from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.ctinterpolate-Tuple{Any, Any}","page":"Developers","title":"CTModels.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn a linear interpolation function for the data f defined at points x.\n\nThis function creates a one-dimensional linear interpolant using the  Interpolations.jl package, with linear extrapolation beyond the bounds of x.\n\nArguments\n\nx: A vector of points at which the values f are defined.\nf: A vector of values to interpolate.\n\nReturns\n\nA callable interpolation object that can be evaluated at new points.\n\nExample\n\njulia> x = 0:0.5:2\njulia> f = [0.0, 1.0, 0.0, -1.0, 0.0]\njulia> interp = ctinterpolate(x, f)\njulia> interp(1.2)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.definition!-Tuple{CTModels.PreModel, Expr}","page":"Developers","title":"CTModels.definition!","text":"definition!(ocp::CTModels.PreModel, definition::Expr)\n\n\nSet the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.definition-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.definition","text":"definition(ocp::CTModels.Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.definition-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.definition","text":"definition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear boundary constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of boundary constraints.\n\nReturns\n\nDimension: The dimension of the nonlinear boundary constraints.\n\nExample\n\n# Example of getting the dimension of nonlinear boundary constraints\njulia> model = ConstraintsModel(...)\njulia> dim_boundary = dim_boundary_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_control_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of control box constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of control box constraints.\n\nReturns\n\nDimension: The dimension of the control box constraints.\n\nExample\n\njulia> # Example of getting the dimension of control box constraints\njulia> model = ConstraintsModel(...)\njulia> dim_control = dim_control_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_control_constraints_box-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of path constraints.\n\nReturns\n\nDimension: The dimension of the nonlinear path constraints.\n\nExample\n\n# Example of getting the dimension of nonlinear path constraints\njulia> model = ConstraintsModel(...)\njulia> dim_path = dim_path_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_state_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of state box constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of state box constraints.\n\nReturns\n\nDimension: The dimension of the state box constraints.\n\nExample\n\njulia> # Example of getting the dimension of state box constraints\njulia> model = ConstraintsModel(...)\njulia> dim_state = dim_state_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_state_constraints_box-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Developers","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of variable box constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of variable box constraints.\n\nReturns\n\nDimension: The dimension of the variable box constraints.\n\nExample\n\njulia> # Example of getting the dimension of variable box constraints\njulia> model = ConstraintsModel(...)\njulia> dim_variable = dim_variable_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.ControlModelSolution}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModelSolution) -> Int64\n\n\nGet the control input dimension from the solution.\n\nArguments\n\nmodel::ControlModelSolution: The control model solution.\n\nReturns\n\nDimension: The number of control components.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.ControlModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModel) -> Int64\n\n\nGet the control input dimension.\n\nArguments\n\nmodel::ControlModel: The control model.\n\nReturns\n\nDimension: The number of control components.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.EmptyVariableModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(_::CTModels.EmptyVariableModel) -> Int64\n\n\nReturn 0 since no variable is defined.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.StateModelSolution}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModelSolution) -> Int64\n\n\nGet the dimension of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.StateModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModel) -> Int64\n\n\nGet the dimension of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.VariableModelSolution}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModelSolution) -> Int64\n\n\nReturn the number of components in the variable solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dimension-Tuple{CTModels.VariableModel}","page":"Developers","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModel) -> Int64\n\n\nReturn the dimension (number of components) of the variable.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dual-Tuple{CTModels.Solution, CTModels.Model, Symbol}","page":"Developers","title":"CTModels.dual","text":"dual(\n    sol::CTModels.Solution,\n    model::CTModels.Model,\n    label::Symbol\n) -> Any\n\n\nReturn the dual variable associated with a constraint identified by its label.\n\nSearches through all constraint types (path, boundary, state, control, and variable constraints) defined in the model and returns the corresponding dual value(s) from the solution. If the label is found multiple times, a vector of values is returned.\n\nArguments\n\nsol::Solution: Solution object containing dual variables.\nmodel::Model: Model containing constraint definitions.\nlabel::Symbol: Symbol corresponding to a constraint label.\n\nReturns\n\nA function of time t for time-dependent constraints, or a scalar/vector for time-invariant duals. If the label is not found, throws an IncorrectArgument exception.\n\nExamples\n\njulia> dual_fun = dual(sol, model, :velocity_limit)\njulia> dual_value_at_t1 = dual_fun(1.0)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dual_model-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM}}, Tuple{DM}} where DM<:CTModels.AbstractDualModel","page":"Developers","title":"CTModels.dual_model","text":"dual_model(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM<:CTModels.AbstractDualModel}\n) -> CTModels.AbstractDualModel\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dynamics!-Tuple{CTModels.PreModel, AbstractRange{<:Int64}, Function}","page":"Developers","title":"CTModels.dynamics!","text":"dynamics!(\n    ocp::CTModels.PreModel,\n    rg::AbstractRange{<:Int64},\n    f::Function\n)\n\n\nAdd a partial dynamics function f to the optimal control problem ocp, applying to the subset of state indices specified by the range rg.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\nrg::AbstractRange{<:Int}: Range of state indices to which f applies.\nf::Function: A function describing the dynamics over the specified state indices.\n\nPreconditions\n\nThe state, control, and times must be set before calling this function.\nThe full dynamics must not yet be complete.\nNo overlap is allowed between rg and existing dynamics index ranges.\n\nBehavior\n\nThis function appends the tuple (rg, f) to the list of partial dynamics. It ensures that the specified indices are not already covered and that the system is in a valid configuration for adding partial dynamics.\n\nErrors\n\nThrows CTBase.UnauthorizedCall if:\n\nThe state, control, or times are not yet set.\nThe dynamics are already defined completely.\nAny index in rg overlaps with an existing dynamics range.\n\nExample\n\njulia> dynamics!(ocp, 1:2, (out, t, x, u, v) -> out .= x[1:2] .+ u[1:2])\njulia> dynamics!(ocp, 3:3, (out, t, x, u, v) -> out .= x[3] * v[1])\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Function}","page":"Developers","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, f::Function)\n\n\nSet the full dynamics of the optimal control problem ocp using the function f.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\nf::Function: A function that defines the complete system dynamics.\n\nPreconditions\n\nThe state, control, and times must be set before calling this function.\nNo dynamics must have been set previously.\n\nBehavior\n\nThis function assigns f as the complete dynamics of the system. It throws an error if any of the required fields (state, control, times) are not yet set, or if dynamics have already been set.\n\nErrors\n\nThrows CTBase.UnauthorizedCall if called out of order or in an invalid state.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Integer, Function}","page":"Developers","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, i::Integer, f::Function)\n\n\nDefine partial dynamics for a single state variable index in an optimal control problem.\n\nThis is a convenience method for defining dynamics affecting only one element of the state vector. It wraps the scalar index i into a range i:i and delegates to the general partial dynamics method.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\ni::Integer: The index of the state variable to which the function f applies.\nf::Function: A function of the form (out, t, x, u, v) -> ..., which updates the scalar output out[1] in-place.\n\nBehavior\n\nThis is equivalent to calling:\n\njulia> dynamics!(ocp, i:i, f)\n\nErrors\n\nThrows the same errors as the range-based method if:\n\nThe model is not properly initialized.\nThe index i overlaps with existing dynamics.\nA full dynamics function is already defined.\n\nExample\n\njulia> dynamics!(ocp, 3, (out, t, x, u, v) -> out[1] = x[3]^2 + u[1])\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.dynamics-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D}}, Tuple{D}} where D<:Function","page":"Developers","title":"CTModels.dynamics","text":"dynamics(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nGet the dynamics from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.export_ocp_solution-Tuple{CTModels.AbstractSolution}","page":"Developers","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    sol::CTModels.AbstractSolution;\n    format,\n    filename\n)\n\n\nExport a solution in JLD or JSON formats.\n\nExamples\n\njulia> CTModels.export_ocp_solution(sol; filename=\"solution\", format=:JSON)\njulia> CTModels.export_ocp_solution(sol; filename=\"solution\", format=:JLD)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.export_ocp_solution-Tuple{CTModels.JLD2Tag, CTModels.AbstractSolution}","page":"Developers","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    ::CTModels.JLD2Tag,\n    ::CTModels.AbstractSolution;\n    filename\n)\n\n\nExport a solution in JLD format.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.export_ocp_solution-Tuple{CTModels.JSON3Tag, CTModels.AbstractSolution}","page":"Developers","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    ::CTModels.JSON3Tag,\n    ::CTModels.AbstractSolution;\n    filename\n)\n\n\nExport a solution in JSON format.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF}}, Tuple{TF}} where TF<:CTModels.AbstractTimeModel","page":"Developers","title":"CTModels.final","text":"final(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Tuple{CTModels.AbstractModel, AbstractVector}","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.AbstractModel,\n    variable::AbstractVector\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Tuple{CTModels.AbstractModel}","page":"Developers","title":"CTModels.final_time","text":"final_time(ocp::CTModels.AbstractModel) -> Real\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the final time from the model, for a fixed final time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, T}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.final_time_name","text":"final_time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the final time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.final_time_name","text":"final_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the final time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.final_time_name-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.formatData-Tuple{Any}","page":"Developers","title":"CTModels.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.formatTimeGrid-Tuple{Any}","page":"Developers","title":"CTModels.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_final_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_final_time-Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}","page":"Developers","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_initial_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_initial_time-Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}}","page":"Developers","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_fixed_initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_final_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_free_final_time","text":"has_free_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_final_time-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_initial_time-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_free_initial_time-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.BolzaObjectiveModel\n) -> Bool\n\n\nCheck if the Bolza objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.MayerObjectiveModel}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.MayerObjectiveModel\n) -> Bool\n\n\nCheck if the Mayer objective model has a Lagrange function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_lagrange_cost-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.BolzaObjectiveModel) -> Bool\n\n\nCheck if the Bolza objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Mayer function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.MayerObjectiveModel}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.MayerObjectiveModel) -> Bool\n\n\nCheck if the Mayer objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.has_mayer_cost-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.import_ocp_solution-Tuple{CTModels.AbstractModel}","page":"Developers","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ocp::CTModels.AbstractModel;\n    format,\n    filename\n)\n\n\nImport a solution from a JLD or JSON file.\n\nExamples\n\njulia> sol = CTModels.import_ocp_solution(ocp; filename=\"solution\", format=:JSON)\njulia> sol = CTModels.import_ocp_solution(ocp; filename=\"solution\", format=:JLD)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.import_ocp_solution-Tuple{CTModels.JLD2Tag, CTModels.AbstractModel}","page":"Developers","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ::CTModels.JLD2Tag,\n    ::CTModels.AbstractModel;\n    filename\n)\n\n\nImport a solution from a JLD file.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.import_ocp_solution-Tuple{CTModels.JSON3Tag, CTModels.AbstractModel}","page":"Developers","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ::CTModels.JSON3Tag,\n    ::CTModels.AbstractModel;\n    filename\n)\n\n\nImport a solution from a JLD file.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.index-Tuple{CTModels.FreeTimeModel}","page":"Developers","title":"CTModels.index","text":"index(model::CTModels.FreeTimeModel) -> Int64\n\n\nGet the index of the time variable from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.infos-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.infos","text":"infos(sol::CTModels.Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial-Union{Tuple{CTModels.TimesModel{TI}}, Tuple{TI}} where TI<:CTModels.AbstractTimeModel","page":"Developers","title":"CTModels.initial","text":"initial(\n    model::CTModels.TimesModel{TI<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the initial time from the model, for a fixed initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}}, T}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.initial_time_name","text":"initial_time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the initial time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.initial_time_name","text":"initial_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the initial time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.initial_time_name-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.is_autonomous-Tuple{CTModels.Model{CTModels.Autonomous, <:CTModels.TimesModel}}","page":"Developers","title":"CTModels.is_autonomous","text":"is_autonomous(\n    _::CTModels.Model{CTModels.Autonomous, <:CTModels.TimesModel}\n) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.is_empty_time_grid-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.is_empty_time_grid","text":"is_empty_time_grid(sol::CTModels.Solution) -> Bool\n\n\nCheck if the time grid is empty from the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.isaVectVect-Tuple{Any}","page":"Developers","title":"CTModels.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.isempty_constraints-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.isempty_constraints","text":"isempty_constraints(ocp::CTModels.Model) -> Bool\n\n\nReturn true if the model has constraints or false if not.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.iterations-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.iterations","text":"iterations(sol::CTModels.Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.BolzaObjectiveModel{<:Function, L}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.LagrangeObjectiveModel{L}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L}}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L}}}, Tuple{L}} where L<:Function","page":"Developers","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.matrix2vec","page":"Developers","title":"CTModels.matrix2vec","text":"matrix2vec(A::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    A::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransform a matrix into a vector of vectors along the specified dimension.\n\nEach row or column of the matrix A is extracted and stored as an individual vector, depending on dim.\n\nArguments\n\nA: A matrix of elements of type <:ctNumber.\ndim: The dimension along which to split the matrix (1 for rows, 2 for columns). Defaults to 1.\n\nReturns\n\nA Vector of Vectors extracted from the rows or columns of A.\n\nNote\n\nThis is useful when data needs to be represented as a sequence of state or control vectors in optimal control problems.\n\nExample\n\njulia> A = [1 2 3; 4 5 6]\njulia> matrix2vec(A, 1)  # splits into rows: [[1, 2, 3], [4, 5, 6]]\njulia> matrix2vec(A, 2)  # splits into columns: [[1, 4], [2, 5], [3, 6]]\n\n\n\n\n\n","category":"function"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.BolzaObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.MayerObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"Developers","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.message-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.message","text":"message(sol::CTModels.Solution) -> String\n\n\nReturn the message associated to the stopping criterion of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.model-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, <:CTModels.AbstractDualModel, <:CTModels.AbstractSolverInfos, TM}}, Tuple{TM}} where TM<:CTModels.AbstractModel","page":"Developers","title":"CTModels.model","text":"model(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, <:CTModels.AbstractDualModel, <:CTModels.AbstractSolverInfos, TM<:CTModels.AbstractModel}\n) -> CTModels.AbstractModel\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.ControlModelSolution}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.ControlModelSolution) -> String\n\n\nGet the name of the control variable from the solution.\n\nArguments\n\nmodel::ControlModelSolution: The control model solution.\n\nReturns\n\nString: The name of the control.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.ControlModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.ControlModel) -> String\n\n\nGet the name of the control variable.\n\nArguments\n\nmodel::ControlModel: The control model.\n\nReturns\n\nString: The name of the control.\n\nExample\n\njulia> name(controlmodel)\n\"u\"\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.EmptyVariableModel}","page":"Developers","title":"CTModels.name","text":"name(_::CTModels.EmptyVariableModel) -> String\n\n\nReturn an empty string, since no variable is defined.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.FixedTimeModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.FixedTimeModel) -> String\n\n\nGet the name of the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.FreeTimeModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.FreeTimeModel) -> String\n\n\nGet the name of the time from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.StateModelSolution}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.StateModelSolution) -> String\n\n\nGet the name of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.StateModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.StateModel) -> String\n\n\nGet the name of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.VariableModelSolution}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.VariableModelSolution) -> String\n\n\nReturn the name of the variable stored in the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.name-Tuple{CTModels.VariableModel}","page":"Developers","title":"CTModels.name","text":"name(model::CTModels.VariableModel) -> String\n\n\nReturn the name of the variable stored in the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.objective!","page":"Developers","title":"CTModels.objective!","text":"objective!(ocp::CTModels.PreModel; ...)\nobjective!(\n    ocp::CTModels.PreModel,\n    criterion::Symbol;\n    mayer,\n    lagrange\n)\n\n\nSet the objective of the optimal control problem.\n\nArguments\n\nocp::PreModel: the optimal control problem.\ncriterion::Symbol: the type of criterion. Either :min or :max. Default is :min.\nmayer::Union{Function, Nothing}: the Mayer function (inplace). Default is nothing.\nlagrange::Union{Function, Nothing}: the Lagrange function (inplace). Default is nothing.\n\nnote: Note\nThe state, control and variable must be set before the objective.\nThe objective must not be set before.\nAt least one of the two functions must be given. Please provide a Mayer or a Lagrange function.\n\nExamples\n\njulia> function mayer(x0, xf, v)\n           return x0[1] + xf[1] + v[1]\n       end\njuila> function lagrange(t, x, u, v)\n           return x[1] + u[1] + v[1]\n       end\njulia> objective!(ocp, :min, mayer=mayer, lagrange=lagrange)\n\n\n\n\n\n","category":"function"},{"location":"dev.html#CTModels.objective-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:CTModels.AbstractObjectiveModel","page":"Developers","title":"CTModels.objective","text":"objective(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nGet the objective from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.objective-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:Real","page":"Developers","title":"CTModels.objective","text":"objective(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the dual of the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_dual-Union{Tuple{CTModels.DualModel{PC_Dual}}, Tuple{PC_Dual}} where PC_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    model::CTModels.DualModel{PC_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the nonlinear path constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for path constraints.\n\nReturns\n\nA function mapping time t to the vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{TP}}, Tuple{TP}} where TP","page":"Developers","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    model::CTModels.ConstraintsModel{TP}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the path constraints.\n\nReturns\n\nThe nonlinear path constraints.\n\nExample\n\n# Example of retrieving nonlinear path constraints\njulia> model = ConstraintsModel(...)\njulia> path_constraints = path_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP}}}, Tuple{TP}} where TP<:Tuple","page":"Developers","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP<:Tuple}}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Developers","title":"CTModels.state!","text":"state!(ocp::CTModels.PreModel, n::Int64)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol}\n)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\", [\"u\", \"v\"])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\njulia> state!(ocp, 2, \"y\", [:u, :v])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, T}}, Tuple{T}} where T<:CTModels.AbstractStateModel","page":"Developers","title":"CTModels.state","text":"state(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nGet the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.state","text":"state(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_components-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.state_components","text":"state_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_components-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_components","text":"state_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}, Tuple{TS}} where TS","page":"Developers","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}\n) -> Any\n\n\nGet the state box constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the state box constraints.\n\nReturns\n\nThe state box constraints.\n\nExample\n\n# Example of retrieving state box constraints\njulia> model = ConstraintsModel(...)\njulia> state_constraints = state_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}}, Tuple{TS}} where TS<:Tuple","page":"Developers","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS<:Tuple}}\n) -> Any\n\n\nGet the box constraints on state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual}}, Tuple{SC_LB_Dual}} where SC_LB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the lower bounds of state constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for state lower bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual}}, Tuple{SC_UB_Dual}} where SC_UB_Dual<:Union{Nothing, Function}","page":"Developers","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the upper bounds of state constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for state upper bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_dimension-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the state dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_dimension-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.PreModel) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_dimension-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_dimension","text":"state_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.state_name","text":"state_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.state_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.state_name","text":"state_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.stopping-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.stopping","text":"stopping(sol::CTModels.Solution) -> Symbol\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.success-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.success","text":"success(sol::CTModels.Solution) -> Bool\n\n\nReturn the success status of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time!-Tuple{CTModels.PreModel}","page":"Developers","title":"CTModels.time!","text":"time!(ocp::CTModels.PreModel; t0, tf, ind0, indf, time_name)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then, one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, time_name=\"s\") # time_name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, time_name=:s ) # time_name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time-Union{Tuple{CTModels.FixedTimeModel{T}}, Tuple{T}} where T<:Real","page":"Developers","title":"CTModels.time","text":"time(model::CTModels.FixedTimeModel{T<:Real}) -> Real\n\n\nGet the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time-Union{Tuple{T}, Tuple{CTModels.FreeTimeModel, AbstractVector{T}}} where T<:Real","page":"Developers","title":"CTModels.time","text":"time(\n    model::CTModels.FreeTimeModel,\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the time from the free time model.\n\nExceptions\n\nIf the index of the time variable is not in [1, length(variable)], throw an error.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_grid-Union{Tuple{CTModels.Solution{<:CTModels.TimeGridModel{T}}}, Tuple{T}} where T<:Union{StepRangeLen, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.time_grid","text":"time_grid(\n    sol::CTModels.Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.time_name","text":"time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.time_name","text":"time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the time component of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.time_name-Tuple{CTModels.TimesModel}","page":"Developers","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.times-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, T}}, Tuple{T}} where T<:CTModels.TimesModel","page":"Developers","title":"CTModels.times","text":"times(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nGet the times from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.to_out_of_place-Tuple{Any, Any}","page":"Developers","title":"CTModels.to_out_of_place","text":"to_out_of_place(\n    f!,\n    n;\n    T\n) -> Union{Nothing, CTModels.var\"#f#13\"{CTModels.var\"#f#12#14\"{DataType, _A, _B}} where {_A, _B}}\n\n\nConvert an in-place function f! to an out-of-place function f.\n\nThe resulting function f returns a vector of type T and length n by first allocating memory and then calling f! to fill it.\n\nArguments\n\nf!: An in-place function of the form f!(result, args...).\nn: The length of the output vector.\nT: The element type of the output vector (default is Float64).\n\nReturns\n\nAn out-of-place function f(args...; kwargs...) that returns the result as a vector or scalar, depending on n.\n\nExample\n\njulia> f!(r, x) = (r[1] = sin(x); r[2] = cos(x))\njulia> f = to_out_of_place(f!, 2)\njulia> f(π/4)  # returns approximately [0.707, 0.707]\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.value-Union{Tuple{CTModels.ControlModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.value","text":"value(\n    model::CTModels.ControlModelSolution{TS<:Function}\n) -> Function\n\n\nGet the control function associated with the solution.\n\nArguments\n\nmodel::ControlModelSolution{TS}: The control model solution.\n\nReturns\n\nTS: A function giving the control value at a given time or state.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.value-Union{Tuple{CTModels.StateModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"Developers","title":"CTModels.value","text":"value(\n    model::CTModels.StateModelSolution{TS<:Function}\n) -> Function\n\n\nGet the state function from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.value-Union{Tuple{CTModels.VariableModelSolution{TS}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.value","text":"value(\n    model::CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the value stored in the variable solution model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Developers","title":"CTModels.variable!","text":"variable!(ocp::CTModels.PreModel, q::Int64)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol}\n)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine a new variable in the optimal control problem ocp with dimension q.\n\nThis function registers a named variable (e.g. \"state\", \"control\", or other) to be used in the problem definition. You may optionally specify a name and individual component names.\n\nnote: Note\nYou can call variable! only once. It must be called before setting the objective or dynamics.\n\nArguments\n\nocp: The PreModel where the variable is registered.\nq: The dimension of the variable (number of components).\nname: A name for the variable (default: auto-generated from q).\ncomponents_names: A vector of strings or symbols for each component (default: [\"v₁\", \"v₂\", ...]).\n\nExamples\n\nvariable!(ocp, 1, \"v\")\nvariable!(ocp, 2, \"v\", [\"v₁\", \"v₂\"])\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T}}, Tuple{T}} where T<:CTModels.AbstractVariableModel","page":"Developers","title":"CTModels.variable","text":"variable(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nGet the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.variable","text":"variable(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_components-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.variable_components","text":"variable_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_components-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_components","text":"variable_components(\n    sol::CTModels.Solution\n) -> Vector{String}\n\n\nReturn the names of the components of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}, Tuple{TV}} where TV","page":"Developers","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}\n) -> Any\n\n\nGet the variable box constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the variable box constraints.\n\nReturns\n\nThe variable box constraints.\n\nExample\n\n# Example of retrieving variable box constraints\njulia> model = ConstraintsModel(...)\njulia> variable_constraints = variable_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}}, Tuple{TV}} where TV<:Tuple","page":"Developers","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV<:Tuple}}\n) -> Any\n\n\nGet the box constraints on variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the lower bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual}}, Tuple{VC_LB_Dual}} where VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual vector associated with the lower bounds of variable constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for variable lower bounds.\n\nReturns\n\nA vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the upper bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual}}, Tuple{VC_UB_Dual}} where VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"Developers","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual vector associated with the upper bounds of variable constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for variable upper bounds.\n\nReturns\n\nA vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_dimension-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the variable dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_dimension-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_dimension","text":"variable_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_name-Tuple{CTModels.Model}","page":"Developers","title":"CTModels.variable_name","text":"variable_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.variable_name-Tuple{CTModels.Solution}","page":"Developers","title":"CTModels.variable_name","text":"variable_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#RecipesBase.plot-Tuple{CTModels.AbstractSolution, Vararg{Symbol}}","page":"Developers","title":"RecipesBase.plot","text":"plot(\n    sol::CTModels.AbstractSolution,\n    description::Symbol...;\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a solution from an optimal control problem.\n\nThis function dispatches on a solution type that inherits from AbstractSolution. It is intended to visualize various components of the solution (such as state trajectories, controls, costates, or any other variables defined in the model).\n\nnote: Note\nThis function requires the Plots.jl package to be available. If it is not loaded, a CTBase.ExtensionError(:Plots) is thrown.\n\nArguments\n\nsol::AbstractSolution: A solution object returned by solving a control problem.\ndescription::Symbol...: Optional symbols specifying what to plot (e.g., :state, :control, :costate, etc.). If empty, a default set of components is plotted.\nkwargs...: Additional keyword arguments passed to the underlying plotting routines (e.g., xlabel, ylabel, legend, etc.).\n\nReturns\n\nA plot object (if Plots.jl is available) visualizing the selected components of the solution.\n\nExample\n\njulia> using Plots\njulia> plot(sol, :state, :control, xlabel = \"Time\", layout = (2,1))\n\nThrows\n\nCTBase.ExtensionError if the Plots package is not available or not loaded.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTModels.@ensure-Tuple{Any, Any}","page":"Developers","title":"CTModels.@ensure","text":"@ensure condition exception\n\nThrows the provided exception if condition is false.\n\nUsage\n\njulia> @ensure x > 0 CTBase.IncorrectArgument(\"x must be positive\")\n\nArguments\n\ncondition: A Boolean expression to test.\nexception: An instance of an exception to throw if condition is false.\n\nThrows\n\nThe provided exception if the condition is not satisfied.\n\n\n\n\n\n","category":"macro"},{"location":"dev.html#RecipesBase.plot-Tuple{CTModels.Solution, Vararg{Symbol}}","page":"Developers","title":"RecipesBase.plot","text":"plot(\n    sol::CTModels.Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    solution_label,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the components of an optimal control Solution.\n\nThis is the main user-facing function to visualize the solution of an optimal control problem solved with the ControlToolbox.jl ecosystem.\n\nIt generates a plot (or set of subplots) showing the evolution of the state, control, costate, path constraints, and dual variables over time, depending on the user’s choices.\n\nArguments\n\nsol::CTModels.Solution: The optimal control solution to visualize. Typically the result of solving a problem using CTDirect.jl or CTKnitro.jl.\ndescription::Symbol...: A variable number of symbols indicating which components to include in the plot. Common values include:\n:state – plot the state trajectory.\n:costate – plot the costate (adjoint) variables.\n:control – plot the control signal.\n:path – plot the values of nonlinear path constraints.\n:dual – plot the dual variables (Lagrange multipliers) associated with path constraints.\n\nIf no symbols are provided, a default set is used based on the problem and styles.\n\nKeyword Arguments\n\nlayout::Symbol = :group: Specifies how to arrange plots.\n:group: Fewer plots, grouping similar variables together (e.g., all states in one subplot).\n:split: One plot per variable component, stacked in a layout.\ncontrol::Symbol = :components: Defines how to represent control inputs.\n:components: One curve per control component.\n:norm: Single curve showing ‖u(t)‖.\n:all: Plot both components and norm.\ntime::Symbol = :default: Time normalization for plots.\n:default: Real time scale.\n:normalize or :normalise: Normalized to the interval [0, 1].\nsolution_label::String = \"\": Label to annotate this solution in the legend. (Deprecated: use label instead) \n\nStyle Options (Optional)\n\nAll style-related keyword arguments can be either a NamedTuple of plotting attributes or a Symbol referring to a predefined style. These allow you to customize color, line style, markers, etc.\n\nstate_style: Plot style for state components.\ncostate_style: Plot style for costate components.\ncontrol_style: Plot style for control components.\ndual_style: Plot style for dual variables.\npath_style: Plot style for path constraint values.\n\nBounds Decorations (Optional)\n\nUse these options to show bounds on the plots if applicable and defined in the model.\n\nstate_bounds_style: Style for state variable bounds.\ncontrol_bounds_style: Style for control bounds.\npath_bounds_style: Style for path constraint bounds.\ntime_style: Style for vertical lines at initial and final time.\n\nReturns\n\nA Plots.Plot object, which can be displayed, saved, or further customized.\n\nExample\n\n# plot the state and control with default layout\njulia> plot(sol, :state, :control)\n\n# customize layout and styles\njulia> plot(sol, :state, :control;\n     layout = :split,\n     control = :all,\n     state_style = (color=:blue, linestyle=:solid),\n     control_style = (color=:red, linestyle=:dash))\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTModels.jl","page":"Introduction","title":"CTModels.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTModels.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"}]
}
