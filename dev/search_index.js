var documenterSearchIndex = {"docs":
[{"location":"api.html","page":"API","title":"API","text":"CurrentModule = CTModels","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"This page is a dump of all the docstrings found in the code. ","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTModels]\nOrder = [:module, :type, :function, :macro]","category":"page"},{"location":"api.html#CTModels.AbstractConstraintsModel","page":"API","title":"CTModels.AbstractConstraintsModel","text":"abstract type AbstractConstraintsModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractControlModel","page":"API","title":"CTModels.AbstractControlModel","text":"abstract type AbstractControlModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractDualModel","page":"API","title":"CTModels.AbstractDualModel","text":"abstract type AbstractDualModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractModel","page":"API","title":"CTModels.AbstractModel","text":"abstract type AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractObjectiveModel","page":"API","title":"CTModels.AbstractObjectiveModel","text":"abstract type AbstractObjectiveModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractSolution","page":"API","title":"CTModels.AbstractSolution","text":"abstract type AbstractSolution\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractSolverInfos","page":"API","title":"CTModels.AbstractSolverInfos","text":"abstract type AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractStateModel","page":"API","title":"CTModels.AbstractStateModel","text":"abstract type AbstractStateModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractTimeGridModel","page":"API","title":"CTModels.AbstractTimeGridModel","text":"abstract type AbstractTimeGridModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractTimeModel","page":"API","title":"CTModels.AbstractTimeModel","text":"abstract type AbstractTimeModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractTimesModel","page":"API","title":"CTModels.AbstractTimesModel","text":"abstract type AbstractTimesModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.AbstractVariableModel","page":"API","title":"CTModels.AbstractVariableModel","text":"abstract type AbstractVariableModel\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.BolzaObjectiveModel","page":"API","title":"CTModels.BolzaObjectiveModel","text":"struct BolzaObjectiveModel{TM<:Function, TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.ConstraintsModel","page":"API","title":"CTModels.ConstraintsModel","text":"struct ConstraintsModel{TP<:Tuple, TB<:Tuple, TS<:Tuple, TC<:Tuple, TV<:Tuple, TC_ALL<:Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} <: CTModels.AbstractConstraintsModel\n\nFields\n\npath_nl::Tuple\nboundary_nl::Tuple\nstate_box::Tuple\ncontrol_box::Tuple\nvariable_box::Tuple\ndict::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.ControlModel","page":"API","title":"CTModels.ControlModel","text":"struct ControlModel <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.ControlModelSolution","page":"API","title":"CTModels.ControlModelSolution","text":"struct ControlModelSolution{TS<:Function} <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.DualModel","page":"API","title":"CTModels.DualModel","text":"struct DualModel{PC<:Function, PC_Dual<:Function, BC<:(AbstractVector{<:Real}), BC_Dual<:(AbstractVector{<:Real}), SC_LB_Dual<:Function, SC_UB_Dual<:Function, CC_LB_Dual<:Function, CC_UB_Dual<:Function, VC_LB_Dual<:(AbstractVector{<:Real}), VC_UB_Dual<:(AbstractVector{<:Real})} <: CTModels.AbstractDualModel\n\nFields\n\npath_constraints::Function\npath_constraints_dual::Function\nboundary_constraints::AbstractVector{<:Real}\nboundary_constraints_dual::AbstractVector{<:Real}\nstate_constraints_lb_dual::Function\nstate_constraints_ub_dual::Function\ncontrol_constraints_lb_dual::Function\ncontrol_constraints_ub_dual::Function\nvariable_constraints_lb_dual::AbstractVector{<:Real}\nvariable_constraints_ub_dual::AbstractVector{<:Real}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.EmptyTimeGridModel","page":"API","title":"CTModels.EmptyTimeGridModel","text":"struct EmptyTimeGridModel <: CTModels.AbstractTimeGridModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.EmptyVariableModel","page":"API","title":"CTModels.EmptyVariableModel","text":"struct EmptyVariableModel <: CTModels.AbstractVariableModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.FixedTimeModel","page":"API","title":"CTModels.FixedTimeModel","text":"struct FixedTimeModel{T<:Real} <: CTModels.AbstractTimeModel\n\nFields\n\ntime::Real\nname::String\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.FreeTimeModel","page":"API","title":"CTModels.FreeTimeModel","text":"struct FreeTimeModel <: CTModels.AbstractTimeModel\n\nFields\n\nindex::Int64\nname::String\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.Init","page":"API","title":"CTModels.Init","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nInit(): default initialization\nInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nInit(sol): from existing solution\n\nExamples\n\njulia> init = Init()\njulia> init = Init(state=[0.1, 0.2], control=0.3)\njulia> init = Init(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = Init(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = Init(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = Init(sol)\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.LagrangeObjectiveModel","page":"API","title":"CTModels.LagrangeObjectiveModel","text":"struct LagrangeObjectiveModel{TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.MayerObjectiveModel","page":"API","title":"CTModels.MayerObjectiveModel","text":"struct MayerObjectiveModel{TM<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.Model","page":"API","title":"CTModels.Model","text":"struct Model{TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.PreModel","page":"API","title":"CTModels.PreModel","text":"mutable struct PreModel <: CTModels.AbstractModel\n\nFields\n\ntimes::Union{Nothing, CTModels.AbstractTimesModel}: Default: nothing\nstate::Union{Nothing, CTModels.AbstractStateModel}: Default: nothing\ncontrol::Union{Nothing, CTModels.AbstractControlModel}: Default: nothing\nvariable::CTModels.AbstractVariableModel: Default: EmptyVariableModel()\ndynamics::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, CTModels.AbstractObjectiveModel}: Default: nothing\nconstraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}: Default: ConstraintsDictType()\ndefinition::Union{Nothing, Expr}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.Solution","page":"API","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.SolverInfos","page":"API","title":"CTModels.SolverInfos","text":"struct SolverInfos{TI<:Dict{Symbol, Any}} <: CTModels.AbstractSolverInfos\n\nFields\n\niterations::Int64\nstopping::Symbol\nmessage::String\nsuccess::Bool\nconstraints_violation::Float64\ninfos::Dict{Symbol, Any}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.StateModel","page":"API","title":"CTModels.StateModel","text":"struct StateModel <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.StateModelSolution","page":"API","title":"CTModels.StateModelSolution","text":"struct StateModelSolution{TS<:Function} <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.TimeGridModel","page":"API","title":"CTModels.TimeGridModel","text":"struct TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}} <: CTModels.AbstractTimeGridModel\n\nFields\n\nvalue::Union{StepRangeLen, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.TimesModel","page":"API","title":"CTModels.TimesModel","text":"struct TimesModel{TI<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel} <: CTModels.AbstractTimesModel\n\nFields\n\ninitial::CTModels.AbstractTimeModel\nfinal::CTModels.AbstractTimeModel\ntime_name::String\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.VariableModel","page":"API","title":"CTModels.VariableModel","text":"struct VariableModel <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTModels.VariableModelSolution","page":"API","title":"CTModels.VariableModelSolution","text":"struct VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}} <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"api.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Model}","page":"API","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.Model\n) -> Union{Nothing, Vector}\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Solution}","page":"API","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::CTModels.Solution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__constraint!-Tuple{Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}, Symbol, Int64, Int64, Int64}","page":"API","title":"CTModels.__constraint!","text":"__constraint!(\n    ocp_constraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}},\n    type::Symbol,\n    n::Int64,\n    m::Int64,\n    q::Int64;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a dictionary of constraints.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__constraint_label-Tuple{}","page":"API","title":"CTModels.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__control_components-Tuple{Int64, String}","page":"API","title":"CTModels.__control_components","text":"__control_components(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__control_name-Tuple{}","page":"API","title":"CTModels.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__criterion_type-Tuple{}","page":"API","title":"CTModels.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_control_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_definition_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_dynamics_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_objective_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_state_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_times_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__is_variable_set-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__state_components-Tuple{Int64, String}","page":"API","title":"CTModels.__state_components","text":"__state_components(n::Int64, name::String) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__state_name-Tuple{}","page":"API","title":"CTModels.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__time_name-Tuple{}","page":"API","title":"CTModels.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__variable_components-Tuple{Int64, String}","page":"API","title":"CTModels.__variable_components","text":"__variable_components(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.__variable_name-Tuple{Int64}","page":"API","title":"CTModels.__variable_name","text":"__variable_name(q::Int64) -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.boundary_constraints-Tuple{CTModels.Solution}","page":"API","title":"CTModels.boundary_constraints","text":"boundary_constraints(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.boundary_constraints_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the dual of the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB}}}, Tuple{TB}} where TB<:Tuple","page":"API","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB<:Tuple}}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.buildFunctionalInit-Tuple{Any, Any, Any}","page":"API","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTModels.var\"#10#11\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.buildFunctionalInit-Tuple{Function, Any, Any}","page":"API","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTModels.var\"#12#13\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"API","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTModels.var\"#10#11\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"API","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTModels.var\"#14#16\", CTModels.var\"#15#17\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.buildVectorInit-Tuple{Any, Any}","page":"API","title":"CTModels.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.build_constraints-Tuple{Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}}","page":"API","title":"CTModels.build_constraints","text":"build_constraints(\n    constraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n) -> CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}}}\n\n\nBuild a concrete type constraints model from a dictionary of constraints.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.build_model-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.build_model","text":"build_model(\n    pre_ocp::CTModels.PreModel\n) -> CTModels.Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType} where {TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:(CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}}})}\n\n\nBuild a concrete type model from a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.build_solution-Tuple{CTModels.Model, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}, Matrix{Float64}}","page":"API","title":"CTModels.build_solution","text":"build_solution(\n    ocp::CTModels.Model,\n    T::Vector{Float64},\n    X::Matrix{Float64},\n    U::Matrix{Float64},\n    v::Vector{Float64},\n    P::Matrix{Float64};\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    path_constraints,\n    path_constraints_dual,\n    boundary_constraints,\n    boundary_constraints_dual,\n    state_constraints_lb_dual,\n    state_constraints_ub_dual,\n    control_constraints_lb_dual,\n    control_constraints_ub_dual,\n    variable_constraints_lb_dual,\n    variable_constraints_ub_dual\n)\n\n\nBuild a solution from the optimal control problem, the time grid, the state, control, variable, and dual variables.\n\nArguments\n\nocp::Model: the optimal control problem.\nT::Vector{Float64}: the time grid.\nX::Matrix{Float64}: the state trajectory.\nU::Matrix{Float64}: the control trajectory.\nv::Vector{Float64}: the variable trajectory.\nP::Matrix{Float64}: the costate trajectory.\nobjective::Float64: the objective value.\niterations::Int: the number of iterations.\nconstraints_violation::Float64: the constraints violation.\nmessage::String: the message associated to the stopping criterion.\nstopping::Symbol: the stopping criterion.\nsuccess::Bool: the success status.\npath_constraints::Matrix{Float64}: the path constraints.\npath_constraints_dual::Matrix{Float64}: the dual of the path constraints.\nboundary_constraints::Vector{Float64}: the boundary constraints.\nboundary_constraints_dual::Vector{Float64}: the dual of the boundary constraints.\nstate_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the state constraints.\nstate_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the state constraints.\ncontrol_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the control constraints.\ncontrol_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the control constraints.\nvariable_constraints_lb_dual::Vector{Float64}: the lower bound dual of the variable constraints.\nvariable_constraints_ub_dual::Vector{Float64}: the upper bound dual of the variable constraints.\n\nReturns\n\nsol::Solution: the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.checkDim-Tuple{Any, Any}","page":"API","title":"CTModels.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.ControlModelSolution}","page":"API","title":"CTModels.components","text":"components(\n    model::CTModels.ControlModelSolution\n) -> Vector{String}\n\n\nGet the components names of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.ControlModel}","page":"API","title":"CTModels.components","text":"components(model::CTModels.ControlModel) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.EmptyVariableModel}","page":"API","title":"CTModels.components","text":"components(_::CTModels.EmptyVariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the empty variable model. Return an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.StateModelSolution}","page":"API","title":"CTModels.components","text":"components(\n    model::CTModels.StateModelSolution\n) -> Vector{String}\n\n\nGet the components names of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.StateModel}","page":"API","title":"CTModels.components","text":"components(model::CTModels.StateModel) -> Vector{String}\n\n\nGet the components names of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.VariableModelSolution}","page":"API","title":"CTModels.components","text":"components(\n    model::CTModels.VariableModelSolution\n) -> Vector{String}\n\n\nGet the components names of the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.components-Tuple{CTModels.VariableModel}","page":"API","title":"CTModels.components","text":"components(model::CTModels.VariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"API","title":"CTModels.constraint!","text":"constraint!(\n    ocp::CTModels.PreModel,\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.constraint-Tuple{CTModels.Model, Symbol}","page":"API","title":"CTModels.constraint","text":"constraint(ocp::CTModels.Model, label::Symbol) -> Tuple\n\n\nGet a labelled constraint from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.constraints-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C}}, Tuple{C}} where C<:CTModels.AbstractConstraintsModel","page":"API","title":"CTModels.constraints","text":"constraints(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nGet the constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.constraints_violation-Tuple{CTModels.Solution}","page":"API","title":"CTModels.constraints_violation","text":"constraints_violation(sol::CTModels.Solution) -> Float64\n\n\nReturn the constraints violation of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"API","title":"CTModels.control!","text":"control!(ocp::CTModels.PreModel, m::Int64)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol}\n)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\", [\"a\", \"b\"])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\njulia> control!(ocp, 2, \"v\", [:a, :b])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T}}, Tuple{T}} where T<:CTModels.AbstractControlModel","page":"API","title":"CTModels.control","text":"control(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nGet the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"API","title":"CTModels.control","text":"control(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_components-Tuple{CTModels.Model}","page":"API","title":"CTModels.control_components","text":"control_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_components-Tuple{CTModels.Solution}","page":"API","title":"CTModels.control_components","text":"control_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}}, Tuple{TC}} where TC<:Tuple","page":"API","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC<:Tuple}}\n) -> Any\n\n\nGet the box constraints on control from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_constraints_lb_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the lower bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_constraints_ub_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the upper bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_dimension-Tuple{CTModels.Model}","page":"API","title":"CTModels.control_dimension","text":"control_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_dimension-Tuple{CTModels.Solution}","page":"API","title":"CTModels.control_dimension","text":"control_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_name-Tuple{CTModels.Model}","page":"API","title":"CTModels.control_name","text":"control_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.control_name-Tuple{CTModels.Solution}","page":"API","title":"CTModels.control_name","text":"control_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.costate-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co<:Function","page":"API","title":"CTModels.costate","text":"costate(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.criterion-Tuple{CTModels.BolzaObjectiveModel}","page":"API","title":"CTModels.criterion","text":"criterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.criterion-Tuple{CTModels.LagrangeObjectiveModel}","page":"API","title":"CTModels.criterion","text":"criterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.criterion-Tuple{CTModels.MayerObjectiveModel}","page":"API","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.criterion-Tuple{CTModels.Model}","page":"API","title":"CTModels.criterion","text":"criterion(ocp::CTModels.Model) -> Symbol\n\n\nGet the type of criterion (:min or :max) from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.ctinterpolate-Tuple{Any, Any}","page":"API","title":"CTModels.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.definition!-Tuple{CTModels.PreModel, Expr}","page":"API","title":"CTModels.definition!","text":"definition!(ocp::CTModels.PreModel, definition::Expr)\n\n\nSet the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.definition-Tuple{CTModels.Model}","page":"API","title":"CTModels.definition","text":"definition(ocp::CTModels.Model) -> Expr\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.Model}","page":"API","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dim_control_constraints_box-Tuple{CTModels.Model}","page":"API","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.Model}","page":"API","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dim_state_constraints_box-Tuple{CTModels.Model}","page":"API","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.Model}","page":"API","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.ControlModelSolution}","page":"API","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModelSolution) -> Int64\n\n\nGet the control dimension from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.ControlModel}","page":"API","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModel) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.EmptyVariableModel}","page":"API","title":"CTModels.dimension","text":"dimension(_::CTModels.EmptyVariableModel) -> Int64\n\n\nGet the variable dimension from the empty variable model. Return 0.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.StateModelSolution}","page":"API","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModelSolution) -> Int64\n\n\nGet the dimension of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.StateModel}","page":"API","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModel) -> Int64\n\n\nGet the dimension of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.VariableModelSolution}","page":"API","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModelSolution) -> Int64\n\n\nGet the variable dimension from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dimension-Tuple{CTModels.VariableModel}","page":"API","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModel) -> Int64\n\n\nGet the variable dimension from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Function}","page":"API","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, f::Function)\n\n\nSet the dynamics of the optimal control problem, in a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.dynamics-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D}}, Tuple{D}} where D<:Function","page":"API","title":"CTModels.dynamics","text":"dynamics(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nGet the dynamics from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF}}, Tuple{TF}} where TF<:CTModels.AbstractTimeModel","page":"API","title":"CTModels.final","text":"final(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time-Union{Tuple{CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the final time from the model, for a fixed final time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"API","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"API","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time_name-Tuple{CTModels.Model}","page":"API","title":"CTModels.final_time_name","text":"final_time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the final time from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time_name-Tuple{CTModels.Solution}","page":"API","title":"CTModels.final_time_name","text":"final_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the final time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.final_time_name-Tuple{CTModels.TimesModel}","page":"API","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.formatData-Tuple{Any}","page":"API","title":"CTModels.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.formatTimeGrid-Tuple{Any}","page":"API","title":"CTModels.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_fixed_final_time-Tuple{CTModels.Model}","page":"API","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_fixed_final_time-Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}","page":"API","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_fixed_final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_fixed_initial_time-Tuple{CTModels.Model}","page":"API","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_fixed_initial_time-Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}}","page":"API","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_fixed_initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_free_final_time-Tuple{CTModels.Model}","page":"API","title":"CTModels.has_free_final_time","text":"has_free_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_free_final_time-Tuple{CTModels.TimesModel}","page":"API","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_free_initial_time-Tuple{CTModels.Model}","page":"API","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_free_initial_time-Tuple{CTModels.TimesModel}","page":"API","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_lagrange_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"API","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.BolzaObjectiveModel\n) -> Bool\n\n\nCheck if the Bolza objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_lagrange_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"API","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_lagrange_cost-Tuple{CTModels.MayerObjectiveModel}","page":"API","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.MayerObjectiveModel\n) -> Bool\n\n\nCheck if the Mayer objective model has a Lagrange function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_lagrange_cost-Tuple{CTModels.Model}","page":"API","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_mayer_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"API","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.BolzaObjectiveModel) -> Bool\n\n\nCheck if the Bolza objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_mayer_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"API","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Mayer function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_mayer_cost-Tuple{CTModels.MayerObjectiveModel}","page":"API","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.MayerObjectiveModel) -> Bool\n\n\nCheck if the Mayer objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.has_mayer_cost-Tuple{CTModels.Model}","page":"API","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.index-Tuple{CTModels.FreeTimeModel}","page":"API","title":"CTModels.index","text":"index(model::CTModels.FreeTimeModel) -> Int64\n\n\nGet the index of the time variable from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.infos-Tuple{CTModels.Solution}","page":"API","title":"CTModels.infos","text":"infos(sol::CTModels.Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial-Union{Tuple{CTModels.TimesModel{TI}}, Tuple{TI}} where TI<:CTModels.AbstractTimeModel","page":"API","title":"CTModels.initial","text":"initial(\n    model::CTModels.TimesModel{TI<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time-Union{Tuple{CTModels.Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the initial time from the model, for a fixed initial time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"API","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"API","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time_name-Tuple{CTModels.Model}","page":"API","title":"CTModels.initial_time_name","text":"initial_time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the initial time from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time_name-Tuple{CTModels.Solution}","page":"API","title":"CTModels.initial_time_name","text":"initial_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the initial time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.initial_time_name-Tuple{CTModels.TimesModel}","page":"API","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.is_empty_time_grid-Tuple{CTModels.Solution}","page":"API","title":"CTModels.is_empty_time_grid","text":"is_empty_time_grid(sol::CTModels.Solution) -> Bool\n\n\nCheck if the time grid is empty from the solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.isaVectVect-Tuple{Any}","page":"API","title":"CTModels.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.iterations-Tuple{CTModels.Solution}","page":"API","title":"CTModels.iterations","text":"iterations(sol::CTModels.Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.lagrange-Union{Tuple{CTModels.BolzaObjectiveModel{<:Function, L}}, Tuple{L}} where L<:Function","page":"API","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.lagrange-Union{Tuple{CTModels.LagrangeObjectiveModel{L}}, Tuple{L}} where L<:Function","page":"API","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L}}}, Tuple{L}} where L<:Function","page":"API","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L}}}, Tuple{L}} where L<:Function","page":"API","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.matrix2vec","page":"API","title":"CTModels.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CTModels.mayer-Union{Tuple{CTModels.BolzaObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"API","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.mayer-Union{Tuple{CTModels.MayerObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"API","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"API","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"API","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.message-Tuple{CTModels.Solution}","page":"API","title":"CTModels.message","text":"message(sol::CTModels.Solution) -> String\n\n\nReturn the message associated to the stopping criterion of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.ControlModelSolution}","page":"API","title":"CTModels.name","text":"name(model::CTModels.ControlModelSolution) -> String\n\n\nGet the name of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.ControlModel}","page":"API","title":"CTModels.name","text":"name(model::CTModels.ControlModel) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.EmptyVariableModel}","page":"API","title":"CTModels.name","text":"name(_::CTModels.EmptyVariableModel) -> String\n\n\nGet the variable name from the empty variable model. Return an empty string.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.FixedTimeModel}","page":"API","title":"CTModels.name","text":"name(model::CTModels.FixedTimeModel) -> String\n\n\nGet the name of the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.FreeTimeModel}","page":"API","title":"CTModels.name","text":"name(model::CTModels.FreeTimeModel) -> String\n\n\nGet the name of the time from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.StateModelSolution}","page":"API","title":"CTModels.name","text":"name(model::CTModels.StateModelSolution) -> String\n\n\nGet the name of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.StateModel}","page":"API","title":"CTModels.name","text":"name(model::CTModels.StateModel) -> String\n\n\nGet the name of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.VariableModelSolution}","page":"API","title":"CTModels.name","text":"name(model::CTModels.VariableModelSolution) -> String\n\n\nGet the variable name from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.name-Tuple{CTModels.VariableModel}","page":"API","title":"CTModels.name","text":"name(model::CTModels.VariableModel) -> String\n\n\nGet the variable name from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.objective!","page":"API","title":"CTModels.objective!","text":"objective!(ocp::CTModels.PreModel; ...)\nobjective!(\n    ocp::CTModels.PreModel,\n    criterion::Symbol;\n    mayer,\n    lagrange\n)\n\n\nSet the objective of the optimal control problem.\n\nArguments\n\nocp::PreModel: the optimal control problem.\ncriterion::Symbol: the type of criterion. Either :min or :max. Default is :min.\nmayer::Union{Function, Nothing}: the Mayer function (inplace). Default is nothing.\nlagrange::Union{Function, Nothing}: the Lagrange function (inplace). Default is nothing.\n\nnote: Note\nThe state, control and variable must be set before the objective.\nThe objective must not be set before.\nAt least one of the two functions must be given. Please provide a Mayer or a Lagrange function.\n\nExamples\n\n```@example julia> function mayer(x0, xf, v)            return x0[1] + xf[1] + v[1]        end juila> function lagrange(t, x, u, v)            return x[1] + u[1] + v[1]        end julia> objective!(ocp, :min, mayer=mayer, lagrange=lagrange)\n\n\n\n\n\n","category":"function"},{"location":"api.html#CTModels.objective-Union{Tuple{CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:CTModels.AbstractObjectiveModel","page":"API","title":"CTModels.objective","text":"objective(\n    ocp::CTModels.Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nGet the objective from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.objective-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:Real","page":"API","title":"CTModels.objective","text":"objective(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.path_constraints-Tuple{CTModels.Solution}","page":"API","title":"CTModels.path_constraints","text":"path_constraints(sol::CTModels.Solution) -> Function\n\n\nReturn the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.path_constraints_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(sol::CTModels.Solution) -> Function\n\n\nReturn the dual of the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP}}}, Tuple{TP}} where TP<:Tuple","page":"API","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP<:Tuple}}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"API","title":"CTModels.state!","text":"state!(ocp::CTModels.PreModel, n::Int64)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol}\n)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\", [\"u\", \"v\"])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\njulia> state!(ocp, 2, \"y\", [:u, :v])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, T}}, Tuple{T}} where T<:CTModels.AbstractStateModel","page":"API","title":"CTModels.state","text":"state(\n    ocp::CTModels.Model{<:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nGet the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"API","title":"CTModels.state","text":"state(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_components-Tuple{CTModels.Model}","page":"API","title":"CTModels.state_components","text":"state_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_components-Tuple{CTModels.Solution}","page":"API","title":"CTModels.state_components","text":"state_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}}, Tuple{TS}} where TS<:Tuple","page":"API","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS<:Tuple}}\n) -> Any\n\n\nGet the box constraints on state from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_constraints_lb_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the lower bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_constraints_ub_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the upper bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_dimension-Tuple{CTModels.Model}","page":"API","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the state dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_dimension-Tuple{CTModels.Solution}","page":"API","title":"CTModels.state_dimension","text":"state_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_name-Tuple{CTModels.Model}","page":"API","title":"CTModels.state_name","text":"state_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.state_name-Tuple{CTModels.Solution}","page":"API","title":"CTModels.state_name","text":"state_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.stopping-Tuple{CTModels.Solution}","page":"API","title":"CTModels.stopping","text":"stopping(sol::CTModels.Solution) -> Symbol\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.success-Tuple{CTModels.Solution}","page":"API","title":"CTModels.success","text":"success(sol::CTModels.Solution) -> Bool\n\n\nReturn the success status of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time!-Tuple{CTModels.PreModel}","page":"API","title":"CTModels.time!","text":"time!(ocp::CTModels.PreModel; t0, tf, ind0, indf, time_name)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then, one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time-Union{Tuple{CTModels.FixedTimeModel{T}}, Tuple{T}} where T<:Real","page":"API","title":"CTModels.time","text":"time(model::CTModels.FixedTimeModel{T<:Real}) -> Real\n\n\nGet the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time-Union{Tuple{T}, Tuple{CTModels.FreeTimeModel, AbstractVector{T}}} where T<:Real","page":"API","title":"CTModels.time","text":"time(\n    model::CTModels.FreeTimeModel,\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the time from the free time model.\n\nExceptions\n\nIf the index of the time variable is not in [1, length(variable)], throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time_grid-Union{Tuple{CTModels.Solution{<:CTModels.TimeGridModel{T}}}, Tuple{T}} where T<:Union{StepRangeLen, AbstractVector{<:Real}}","page":"API","title":"CTModels.time_grid","text":"time_grid(\n    sol::CTModels.Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time_name-Tuple{CTModels.Model}","page":"API","title":"CTModels.time_name","text":"time_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the time from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time_name-Tuple{CTModels.Solution}","page":"API","title":"CTModels.time_name","text":"time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the time component of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.time_name-Tuple{CTModels.TimesModel}","page":"API","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.times-Union{Tuple{CTModels.Model{T}}, Tuple{T}} where T<:CTModels.TimesModel","page":"API","title":"CTModels.times","text":"times(\n    ocp::CTModels.Model{T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nGet the times from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.value-Union{Tuple{CTModels.ControlModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"API","title":"CTModels.value","text":"value(\n    model::CTModels.ControlModelSolution{TS<:Function}\n) -> Function\n\n\nGet the control function value from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.value-Union{Tuple{CTModels.StateModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"API","title":"CTModels.value","text":"value(\n    model::CTModels.StateModelSolution{TS<:Function}\n) -> Function\n\n\nGet the state function from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.value-Union{Tuple{CTModels.VariableModelSolution{TS}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"API","title":"CTModels.value","text":"value(\n    model::CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nGet the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"API","title":"CTModels.variable!","text":"variable!(ocp::CTModels.PreModel, q::Int64)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol}\n)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T}}, Tuple{T}} where T<:CTModels.AbstractVariableModel","page":"API","title":"CTModels.variable","text":"variable(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nGet the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"API","title":"CTModels.variable","text":"variable(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_components-Tuple{CTModels.Model}","page":"API","title":"CTModels.variable_components","text":"variable_components(ocp::CTModels.Model) -> Vector{String}\n\n\nGet the components names of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_components-Tuple{CTModels.Solution}","page":"API","title":"CTModels.variable_components","text":"variable_components(\n    sol::CTModels.Solution\n) -> Vector{String}\n\n\nReturn the names of the components of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}}, Tuple{TV}} where TV<:Tuple","page":"API","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV<:Tuple}}\n) -> Any\n\n\nGet the box constraints on variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_constraints_lb_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the lower bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_constraints_ub_dual-Tuple{CTModels.Solution}","page":"API","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the upper bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_dimension-Tuple{CTModels.Model}","page":"API","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::CTModels.Model) -> Int64\n\n\nGet the variable dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_dimension-Tuple{CTModels.Solution}","page":"API","title":"CTModels.variable_dimension","text":"variable_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_name-Tuple{CTModels.Model}","page":"API","title":"CTModels.variable_name","text":"variable_name(ocp::CTModels.Model) -> String\n\n\nGet the name of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTModels.variable_name-Tuple{CTModels.Solution}","page":"API","title":"CTModels.variable_name","text":"variable_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTModels","page":"Introduction","title":"CTModels","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for CTModels.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"}]
}
