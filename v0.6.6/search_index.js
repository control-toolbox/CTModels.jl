var documenterSearchIndex = {"docs":
[{"location":"types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"types.html","page":"Types","title":"Types","text":"Pages   = [\"types.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"types.html#Documentation","page":"Types","title":"Documentation","text":"","category":"section"},{"location":"types.html#CTModels.AbstractConstraintsModel","page":"Types","title":"CTModels.AbstractConstraintsModel","text":"abstract type AbstractConstraintsModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractControlModel","page":"Types","title":"CTModels.AbstractControlModel","text":"abstract type AbstractControlModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractDualModel","page":"Types","title":"CTModels.AbstractDualModel","text":"abstract type AbstractDualModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractModel","page":"Types","title":"CTModels.AbstractModel","text":"abstract type AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractObjectiveModel","page":"Types","title":"CTModels.AbstractObjectiveModel","text":"abstract type AbstractObjectiveModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractSolution","page":"Types","title":"CTModels.AbstractSolution","text":"abstract type AbstractSolution\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractSolverInfos","page":"Types","title":"CTModels.AbstractSolverInfos","text":"abstract type AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractStateModel","page":"Types","title":"CTModels.AbstractStateModel","text":"abstract type AbstractStateModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractTimeGridModel","page":"Types","title":"CTModels.AbstractTimeGridModel","text":"abstract type AbstractTimeGridModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractTimeModel","page":"Types","title":"CTModels.AbstractTimeModel","text":"abstract type AbstractTimeModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractTimesModel","page":"Types","title":"CTModels.AbstractTimesModel","text":"abstract type AbstractTimesModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.AbstractVariableModel","page":"Types","title":"CTModels.AbstractVariableModel","text":"abstract type AbstractVariableModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.Autonomous","page":"Types","title":"CTModels.Autonomous","text":"abstract type Autonomous <: CTModels.TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.BolzaObjectiveModel","page":"Types","title":"CTModels.BolzaObjectiveModel","text":"struct BolzaObjectiveModel{TM<:Function, TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.ConstraintsModel","page":"Types","title":"CTModels.ConstraintsModel","text":"struct ConstraintsModel{TP<:Tuple, TB<:Tuple, TS<:Tuple, TC<:Tuple, TV<:Tuple} <: CTModels.AbstractConstraintsModel\n\nFields\n\npath_nl::Tuple\nboundary_nl::Tuple\nstate_box::Tuple\ncontrol_box::Tuple\nvariable_box::Tuple\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.ControlModel","page":"Types","title":"CTModels.ControlModel","text":"struct ControlModel <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.ControlModelSolution","page":"Types","title":"CTModels.ControlModelSolution","text":"struct ControlModelSolution{TS<:Function} <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.DualModel","page":"Types","title":"CTModels.DualModel","text":"struct DualModel{PC_Dual<:Union{Nothing, Function}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}} <: CTModels.AbstractDualModel\n\nFields\n\npath_constraints_dual::Union{Nothing, Function}\nboundary_constraints_dual::Union{Nothing, AbstractVector{<:Real}}\nstate_constraints_lb_dual::Union{Nothing, Function}\nstate_constraints_ub_dual::Union{Nothing, Function}\ncontrol_constraints_lb_dual::Union{Nothing, Function}\ncontrol_constraints_ub_dual::Union{Nothing, Function}\nvariable_constraints_lb_dual::Union{Nothing, AbstractVector{<:Real}}\nvariable_constraints_ub_dual::Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.EmptyTimeGridModel","page":"Types","title":"CTModels.EmptyTimeGridModel","text":"struct EmptyTimeGridModel <: CTModels.AbstractTimeGridModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.EmptyVariableModel","page":"Types","title":"CTModels.EmptyVariableModel","text":"struct EmptyVariableModel <: CTModels.AbstractVariableModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.FixedTimeModel","page":"Types","title":"CTModels.FixedTimeModel","text":"struct FixedTimeModel{T<:Real} <: CTModels.AbstractTimeModel\n\nFields\n\ntime::Real\nname::String\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.FreeTimeModel","page":"Types","title":"CTModels.FreeTimeModel","text":"struct FreeTimeModel <: CTModels.AbstractTimeModel\n\nFields\n\nindex::Int64\nname::String\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.LagrangeObjectiveModel","page":"Types","title":"CTModels.LagrangeObjectiveModel","text":"struct LagrangeObjectiveModel{TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.MayerObjectiveModel","page":"Types","title":"CTModels.MayerObjectiveModel","text":"struct MayerObjectiveModel{TM<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.Model","page":"Types","title":"CTModels.Model","text":"struct Model{TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel, BuildExaModelType<:Union{Nothing, Function}} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\nbuild_examodel::Union{Nothing, Function}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.NonAutonomous","page":"Types","title":"CTModels.NonAutonomous","text":"abstract type NonAutonomous <: CTModels.TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.PreModel","page":"Types","title":"CTModels.PreModel","text":"mutable struct PreModel <: CTModels.AbstractModel\n\nFields\n\ntimes::Union{Nothing, CTModels.AbstractTimesModel}: Default: nothing\nstate::Union{Nothing, CTModels.AbstractStateModel}: Default: nothing\ncontrol::Union{Nothing, CTModels.AbstractControlModel}: Default: nothing\nvariable::CTModels.AbstractVariableModel: Default: EmptyVariableModel()\ndynamics::Union{Nothing, Function, Vector{<:Tuple{var\"#s52\", var\"#s53\"} where {var\"#s52\"<:(AbstractRange{<:Int64}), var\"#s53\"<:Function}}}: Default: nothing\nobjective::Union{Nothing, CTModels.AbstractObjectiveModel}: Default: nothing\nconstraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}: Default: ConstraintsDictType()\ndefinition::Union{Nothing, Expr}: Default: nothing\nautonomous::Union{Nothing, Bool}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.Solution","page":"Types","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos, ModelType<:CTModels.AbstractModel} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\nmodel::CTModels.AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.SolverInfos","page":"Types","title":"CTModels.SolverInfos","text":"struct SolverInfos{TI<:Dict{Symbol, Any}} <: CTModels.AbstractSolverInfos\n\nFields\n\niterations::Int64\nstatus::Symbol\nmessage::String\nsuccessful::Bool\nconstraints_violation::Float64\ninfos::Dict{Symbol, Any}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.StateModel","page":"Types","title":"CTModels.StateModel","text":"struct StateModel <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.StateModelSolution","page":"Types","title":"CTModels.StateModelSolution","text":"struct StateModelSolution{TS<:Function} <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.TimeDependence","page":"Types","title":"CTModels.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.TimeGridModel","page":"Types","title":"CTModels.TimeGridModel","text":"struct TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}} <: CTModels.AbstractTimeGridModel\n\nFields\n\nvalue::Union{StepRangeLen, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.TimesModel","page":"Types","title":"CTModels.TimesModel","text":"struct TimesModel{TI<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel} <: CTModels.AbstractTimesModel\n\nFields\n\ninitial::CTModels.AbstractTimeModel\nfinal::CTModels.AbstractTimeModel\ntime_name::String\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.VariableModel","page":"Types","title":"CTModels.VariableModel","text":"struct VariableModel <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.VariableModelSolution","page":"Types","title":"CTModels.VariableModelSolution","text":"struct VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}} <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"types.html#CTModels.__is_autonomous_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_autonomous_set","text":"__is_autonomous_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_complete-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_complete","text":"__is_complete(ocp::CTModels.PreModel) -> Bool\n\n\nReturn true if the PreModel can be built into a Model.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_consistent-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_consistent","text":"__is_consistent(ocp::CTModels.PreModel) -> Bool\n\n\nReturn true if all the required fields are set in the PreModel.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_control_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_control_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_definition_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_definition_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_dynamics_complete-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_dynamics_complete","text":"__is_dynamics_complete(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_dynamics_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_dynamics_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_empty-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_empty","text":"__is_empty(ocp::CTModels.PreModel) -> Bool\n\n\nReturn true if nothing has been set.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_objective_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_objective_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_set-Tuple{Any}","page":"Types","title":"CTModels.__is_set","text":"__is_set(x) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_state_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_state_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_times_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_times_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_variable_empty-Tuple{Any}","page":"Types","title":"CTModels.__is_variable_empty","text":"__is_variable_empty(v) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_variable_set-Tuple{CTModels.Model}","page":"Types","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.__is_variable_set-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.is_empty_time_grid-Tuple{CTModels.Solution}","page":"Types","title":"CTModels.is_empty_time_grid","text":"is_empty_time_grid(sol::CTModels.Solution) -> Bool\n\n\nCheck if the time grid is empty from the solution.\n\n\n\n\n\n","category":"method"},{"location":"types.html#CTModels.state_dimension-Tuple{CTModels.PreModel}","page":"Types","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.PreModel) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"json.html#JSON","page":"JSON","title":"JSON","text":"","category":"section"},{"location":"json.html#Index","page":"JSON","title":"Index","text":"","category":"section"},{"location":"json.html","page":"JSON","title":"JSON","text":"Pages   = [\"json.md\"]\nModules = [CTModels, CTModelsJSON]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"json.html","page":"JSON","title":"JSON","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"json.html#Documentation","page":"JSON","title":"Documentation","text":"","category":"section"},{"location":"json.html#CTModels.export_ocp_solution-Tuple{CTModels.JSON3Tag, CTModels.Solution}","page":"JSON","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    ::CTModels.JSON3Tag,\n    sol::CTModels.Solution;\n    filename\n)\n\n\nExport an optimal control solution to a .json file using the JSON3 format.\n\nThis function serializes a CTModels.Solution into a structured JSON dictionary, including all primal and dual information, which can be read by external tools.\n\nArguments\n\n::CTModels.JSON3Tag: A tag used to dispatch the export method for JSON3.\nsol::CTModels.Solution: The solution to be saved.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base filename. The .json extension is automatically appended.\n\nNotes\n\nThe exported JSON includes the time grid, state, control, costate, objective, solver info, and all constraint duals (if available).\n\nExample\n\njulia> using JSON3\njulia> export_ocp_solution(JSON3Tag(), sol; filename=\"mysolution\")\n# â†’ creates \"mysolution.json\"\n\n\n\n\n\n","category":"method"},{"location":"json.html#CTModels.import_ocp_solution-Tuple{CTModels.JSON3Tag, CTModels.Model}","page":"JSON","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ::CTModels.JSON3Tag,\n    ocp::CTModels.Model;\n    filename\n)\n\n\nImport an optimal control solution from a .json file exported with export_ocp_solution.\n\nThis function reads the JSON contents and reconstructs a CTModels.Solution object, including the discretized primal and dual trajectories.\n\nArguments\n\n::CTModels.JSON3Tag: A tag used to dispatch the import method for JSON3.\nocp::CTModels.Model: The model associated with the optimal control problem. Used to rebuild the full solution.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base filename. The .json extension is automatically appended.\n\nReturns\n\nCTModels.Solution: A reconstructed solution instance.\n\nNotes\n\nHandles both vector and matrix encodings of signals. If dual fields are missing or null, the corresponding attributes are set to nothing.\n\nExample\n\njulia> using JSON3\njulia> sol = import_ocp_solution(JSON3Tag(), model; filename=\"mysolution\")\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#Dual-Model","page":"Dual Model","title":"Dual Model","text":"","category":"section"},{"location":"dual_model.html#Index","page":"Dual Model","title":"Index","text":"","category":"section"},{"location":"dual_model.html","page":"Dual Model","title":"Dual Model","text":"Pages   = [\"dual_model.md\"]\nModules = [CTModels]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dual_model.html#Documentation","page":"Dual Model","title":"Documentation","text":"","category":"section"},{"location":"dual_model.html#CTModels.boundary_constraints_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, BC_Dual}}, Tuple{BC_Dual}} where BC_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"Dual Model","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual vector associated with the boundary constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for boundary constraints.\n\nReturns\n\nA vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.control_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual}}, Tuple{CC_LB_Dual}} where CC_LB_Dual<:Union{Nothing, Function}","page":"Dual Model","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the lower bounds of control constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for control lower bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.control_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual}}, Tuple{CC_UB_Dual}} where CC_UB_Dual<:Union{Nothing, Function}","page":"Dual Model","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the upper bounds of control constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for control upper bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.dual-Tuple{CTModels.Solution, CTModels.Model, Symbol}","page":"Dual Model","title":"CTModels.dual","text":"dual(\n    sol::CTModels.Solution,\n    model::CTModels.Model,\n    label::Symbol\n) -> Any\n\n\nReturn the dual variable associated with a constraint identified by its label.\n\nSearches through all constraint types (path, boundary, state, control, and variable constraints) defined in the model and returns the corresponding dual value from the solution.\n\nArguments\n\nsol::Solution: Solution object containing dual variables.\nmodel::Model: Model containing constraint definitions.\nlabel::Symbol: Symbol corresponding to a constraint label.\n\nReturns\n\nA function of time t for time-dependent constraints, or a scalar/vector for time-invariant duals. If the label is not found, throws an IncorrectArgument exception.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.path_constraints_dual-Union{Tuple{CTModels.DualModel{PC_Dual}}, Tuple{PC_Dual}} where PC_Dual<:Union{Nothing, Function}","page":"Dual Model","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    model::CTModels.DualModel{PC_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the nonlinear path constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for path constraints.\n\nReturns\n\nA function mapping time t to the vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.state_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual}}, Tuple{SC_LB_Dual}} where SC_LB_Dual<:Union{Nothing, Function}","page":"Dual Model","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the lower bounds of state constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for state lower bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.state_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual}}, Tuple{SC_UB_Dual}} where SC_UB_Dual<:Union{Nothing, Function}","page":"Dual Model","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\nReturn the dual function associated with the upper bounds of state constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for state upper bounds.\n\nReturns\n\nA function mapping time t to a vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.variable_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual}}, Tuple{VC_LB_Dual}} where VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"Dual Model","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual vector associated with the lower bounds of variable constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for variable lower bounds.\n\nReturns\n\nA vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"dual_model.html#CTModels.variable_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual}}, Tuple{VC_UB_Dual}} where VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"Dual Model","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual vector associated with the upper bounds of variable constraints.\n\nArguments\n\nmodel::DualModel: A model including dual variables for variable upper bounds.\n\nReturns\n\nA vector of dual values, or nothing if not set.\n\n\n\n\n\n","category":"method"},{"location":"time_dependence.html#Time-dependence","page":"Time dependence","title":"Time dependence","text":"","category":"section"},{"location":"time_dependence.html#Index","page":"Time dependence","title":"Index","text":"","category":"section"},{"location":"time_dependence.html","page":"Time dependence","title":"Time dependence","text":"Pages   = [\"time_dependence.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"time_dependence.html","page":"Time dependence","title":"Time dependence","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"time_dependence.html#Documentation","page":"Time dependence","title":"Documentation","text":"","category":"section"},{"location":"time_dependence.html#CTModels.is_autonomous-Tuple{CTModels.PreModel}","page":"Time dependence","title":"CTModels.is_autonomous","text":"is_autonomous(\n    ocp::CTModels.PreModel\n) -> Union{Nothing, Bool}\n\n\nCheck whether the system is autonomous.\n\nArguments\n\nocp::PreModel: The optimal control problem.\n\nReturns\n\nBool: true if the system is autonomous (i.e., does not explicitly depend on time), false otherwise.\n\nExample\n\njulia> is_autonomous(ocp)  # returns true or false\n\n\n\n\n\n","category":"method"},{"location":"time_dependence.html#CTModels.time_dependence!-Tuple{CTModels.PreModel}","page":"Time dependence","title":"CTModels.time_dependence!","text":"time_dependence!(ocp::CTModels.PreModel; autonomous)\n\n\nSet the time dependence of the optimal control problem ocp.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\nautonomous::Bool: Indicates whether the system is autonomous (true) or time-dependent (false).\n\nPreconditions\n\nThe time dependence must not have been set previously.\n\nBehavior\n\nThis function sets the autonomous field of the model to indicate whether the system's dynamics explicitly depend on time. It can only be called once.\n\nErrors\n\nThrows CTBase.UnauthorizedCall if the time dependence has already been set.\n\nExample\n\njulia> ocp = PreModel(...)\njulia> time_dependence!(ocp; autonomous=true)\n\n\n\n\n\n","category":"method"},{"location":"init.html#Init","page":"Init","title":"Init","text":"","category":"section"},{"location":"init.html#Index","page":"Init","title":"Index","text":"","category":"section"},{"location":"init.html","page":"Init","title":"Init","text":"Pages   = [\"init.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"init.html","page":"Init","title":"Init","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"init.html#Documentation","page":"Init","title":"Documentation","text":"","category":"section"},{"location":"init.html#CTModels.Init","page":"Init","title":"CTModels.Init","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nInit(): default initialization\nInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nInit(sol): from existing solution\n\nExamples\n\njulia> init = Init()\njulia> init = Init(state=[0.1, 0.2], control=0.3)\njulia> init = Init(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = Init(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = Init(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = Init(sol)\n\n\n\n\n\n","category":"type"},{"location":"init.html#CTModels.buildFunctionalInit-Tuple{Any, Any, Any}","page":"Init","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTModels.var\"#25#26\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.buildFunctionalInit-Tuple{Function, Any, Any}","page":"Init","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTModels.var\"#27#28\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"Init","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTModels.var\"#25#26\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"Init","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTModels.var\"#29#31\", CTModels.var\"#30#32\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.buildVectorInit-Tuple{Any, Any}","page":"Init","title":"CTModels.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.checkDim-Tuple{Any, Any}","page":"Init","title":"CTModels.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.formatData-Tuple{Any}","page":"Init","title":"CTModels.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.formatTimeGrid-Tuple{Any}","page":"Init","title":"CTModels.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"init.html#CTModels.isaVectVect-Tuple{Any}","page":"Init","title":"CTModels.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"times.html#Times","page":"Times","title":"Times","text":"","category":"section"},{"location":"times.html#Index","page":"Times","title":"Index","text":"","category":"section"},{"location":"times.html","page":"Times","title":"Times","text":"Pages   = [\"times.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"times.html","page":"Times","title":"Times","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"times.html#Documentation","page":"Times","title":"Documentation","text":"","category":"section"},{"location":"times.html#CTModels.final-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF}}, Tuple{TF}} where TF<:CTModels.AbstractTimeModel","page":"Times","title":"CTModels.final","text":"final(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Times","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"Times","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.final_time_name-Tuple{CTModels.TimesModel}","page":"Times","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.has_fixed_final_time-Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}","page":"Times","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.has_fixed_final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Times","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.has_fixed_initial_time-Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}}","page":"Times","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.has_fixed_initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Times","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.has_free_final_time-Tuple{CTModels.TimesModel}","page":"Times","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.has_free_initial_time-Tuple{CTModels.TimesModel}","page":"Times","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.index-Tuple{CTModels.FreeTimeModel}","page":"Times","title":"CTModels.index","text":"index(model::CTModels.FreeTimeModel) -> Int64\n\n\nGet the index of the time variable from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.initial-Union{Tuple{CTModels.TimesModel{TI}}, Tuple{TI}} where TI<:CTModels.AbstractTimeModel","page":"Times","title":"CTModels.initial","text":"initial(\n    model::CTModels.TimesModel{TI<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"Times","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"Times","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.initial_time_name-Tuple{CTModels.TimesModel}","page":"Times","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.name-Tuple{CTModels.FixedTimeModel}","page":"Times","title":"CTModels.name","text":"name(model::CTModels.FixedTimeModel) -> String\n\n\nGet the name of the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.name-Tuple{CTModels.FreeTimeModel}","page":"Times","title":"CTModels.name","text":"name(model::CTModels.FreeTimeModel) -> String\n\n\nGet the name of the time from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.time!-Tuple{CTModels.PreModel}","page":"Times","title":"CTModels.time!","text":"time!(ocp::CTModels.PreModel; t0, tf, ind0, indf, time_name)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then, one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, time_name=\"s\") # time_name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, time_name=:s ) # time_name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.time-Union{Tuple{CTModels.FixedTimeModel{T}}, Tuple{T}} where T<:Real","page":"Times","title":"CTModels.time","text":"time(model::CTModels.FixedTimeModel{T<:Real}) -> Real\n\n\nGet the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.time-Union{Tuple{T}, Tuple{CTModels.FreeTimeModel, AbstractVector{T}}} where T<:Real","page":"Times","title":"CTModels.time","text":"time(\n    model::CTModels.FreeTimeModel,\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the time from the free time model.\n\nExceptions\n\nIf the index of the time variable is not in [1, length(variable)], throw an error.\n\n\n\n\n\n","category":"method"},{"location":"times.html#CTModels.time_name-Tuple{CTModels.TimesModel}","page":"Times","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\n","category":"method"},{"location":"print.html#Print","page":"Print","title":"Print","text":"","category":"section"},{"location":"print.html#Index","page":"Print","title":"Index","text":"","category":"section"},{"location":"print.html","page":"Print","title":"Print","text":"Pages   = [\"print.md\"]\nModules = [CTModels, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"print.html#Documentation","page":"Print","title":"Documentation","text":"","category":"section"},{"location":"print.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Model}","page":"Print","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.Model\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"print.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.PreModel}","page":"Print","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.PreModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"print.html#Base.show_default-Tuple{IO, CTModels.PreModel}","page":"Print","title":"Base.show_default","text":"show_default(io::IO, ocp::CTModels.PreModel)\n\n\n\n\n\n\n","category":"method"},{"location":"definition.html#Definition","page":"Definition","title":"Definition","text":"","category":"section"},{"location":"definition.html#Index","page":"Definition","title":"Index","text":"","category":"section"},{"location":"definition.html","page":"Definition","title":"Definition","text":"Pages   = [\"definition.md\"]\nModules = [CTModels]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"definition.html#Documentation","page":"Definition","title":"Documentation","text":"","category":"section"},{"location":"definition.html#CTModels.definition!-Tuple{CTModels.PreModel, Expr}","page":"Definition","title":"CTModels.definition!","text":"definition!(ocp::CTModels.PreModel, definition::Expr)\n\n\nSet the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"definition.html#CTModels.definition-Tuple{CTModels.Model}","page":"Definition","title":"CTModels.definition","text":"definition(ocp::CTModels.Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"definition.html#CTModels.definition-Tuple{CTModels.PreModel}","page":"Definition","title":"CTModels.definition","text":"definition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#Plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"plot.html#Index","page":"Plot","title":"Index","text":"","category":"section"},{"location":"plot.html","page":"Plot","title":"Plot","text":"Pages   = [\"plot.md\"]\nModules = [CTModelsPlots, RecipesBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"plot.html","page":"Plot","title":"Plot","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"plot.html#Documentation","page":"Plot","title":"Documentation","text":"","category":"section"},{"location":"plot.html#CTModelsPlots.AbstractPlotTreeElement","page":"Plot","title":"CTModelsPlots.AbstractPlotTreeElement","text":"abstract type AbstractPlotTreeElement\n\nAbstract supertype for nodes used in the plot tree structure. This serves as a base for elements like PlotLeaf, PlotNode, and EmptyPlot.\n\n\n\n\n\n","category":"type"},{"location":"plot.html#CTModelsPlots.EmptyPlot","page":"Plot","title":"CTModelsPlots.EmptyPlot","text":"struct EmptyPlot <: CTModelsPlots.AbstractPlotTreeElement\n\nRepresents an empty placeholder in the plot tree.\n\nUsed to maintain layout consistency when certain plots are omitted.\n\n\n\n\n\n","category":"type"},{"location":"plot.html#CTModelsPlots.PlotLeaf","page":"Plot","title":"CTModelsPlots.PlotLeaf","text":"struct PlotLeaf <: CTModelsPlots.AbstractPlotTreeElement\n\nRepresents a leaf node in a plot tree.\n\nTypically used as an individual plot element without any children.\n\n\n\n\n\n","category":"type"},{"location":"plot.html#CTModelsPlots.PlotNode","page":"Plot","title":"CTModelsPlots.PlotNode","text":"struct PlotNode{TL<:Union{Symbol, Matrix{Any}}, TC<:(Vector{<:CTModelsPlots.AbstractPlotTreeElement})} <: CTModelsPlots.AbstractPlotTreeElement\n\nRepresents a node with a layout and children in a plot tree.\n\nFields\n\nlayout::Union{Symbol, Matrix{Any}}: Layout specification, e.g., :row, :column, or a custom layout matrix.\nchildren::Vector{<:AbstractPlotTreeElement}: Subplots or nested plot nodes.\n\n\n\n\n\n","category":"type"},{"location":"plot.html#CTModelsPlots.__get_data_plot-Tuple{CTModels.Solution, Union{Nothing, CTModels.Model}, Union{Symbol, Tuple{Symbol, Int64}}}","page":"Plot","title":"CTModelsPlots.__get_data_plot","text":"__get_data_plot(\n    sol::CTModels.Solution,\n    model::Union{Nothing, CTModels.Model},\n    xx::Union{Symbol, Tuple{Symbol, Int64}};\n    time\n) -> Any\n\n\nExtract data for plotting from a Solution and optional Model.\n\nArguments\n\nxx: Symbol or (Symbol, Int) indicating the quantity and component.\ntime: Whether to normalize the time grid.\n\nSupported values for xx:\n\n:time, :state, :control, :costate, :control_norm\n:path_constraint, :dual_path_constraint\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__height-Tuple{Real}","page":"Plot","title":"CTModelsPlots.__height","text":"__height(r::Real) -> Expr\n\n\nReturn an expression a{r*h} to control relative plot height when using custom layouts.\n\nUsed for vertical space control in plot trees.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__initial_plot-Tuple{CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"CTModelsPlots.__initial_plot","text":"__initial_plot(\n    sol::CTModels.Solution,\n    description::Symbol...;\n    layout,\n    control,\n    model,\n    state_style,\n    control_style,\n    costate_style,\n    path_style,\n    dual_style,\n    kwargs...\n)\n\n\nInitialize the layout and create an empty plot canvas according to layout and control parameters.\n\nKeyword Arguments\n\nlayout: Plot layout style (:group or :split).\ncontrol: What to plot for controls (:components, :norm, :all).\nstate_style, control_style, etc.: Plot styles for various signals.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__keep_series_attributes-Tuple{}","page":"Plot","title":"CTModelsPlots.__keep_series_attributes","text":"__keep_series_attributes(; kwargs...) -> Vector{Any}\n\n\nFilter keyword arguments to retain only those relevant for plotting series.\n\nReturns a list of key-value pairs recognized by Plots.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot!-Tuple{Plots.Plot, CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"CTModelsPlots.__plot!","text":"__plot!(\n    p::Plots.Plot,\n    sol::CTModels.Solution,\n    description::Symbol...;\n    model,\n    time,\n    control,\n    layout,\n    time_style,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    color,\n    kwargs...\n)\n\n\nPlot an optimal control Solution on a given plot p.\n\nThis updates an existing plot object with the trajectory of states, controls, costates, constraints, and duals based on the provided layout and description.\n\nKeyword Arguments\n\nIncludes options such as:\n\nlayout, control, time\nstate_style, control_style, costate_style, etc.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot-Tuple{CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"CTModelsPlots.__plot","text":"__plot(\n    sol::CTModels.Solution,\n    description::Symbol...;\n    model,\n    time,\n    control,\n    layout,\n    time_style,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    color,\n    kwargs...\n)\n\n\nConstruct and return a new plot for the provided Solution.\n\nThis is a wrapper that calls __initial_plot and then fills it using __plot!.\n\nUse this to obtain a standalone plot.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot_time!-Tuple{Union{Plots.Plot, Plots.Subplot}, CTModels.Solution, Union{Nothing, CTModels.Model}, Int64, Symbol, Symbol}","page":"Plot","title":"CTModelsPlots.__plot_time!","text":"__plot_time!(\n    p::Union{Plots.Plot, Plots.Subplot},\n    sol::CTModels.Solution,\n    model::Union{Nothing, CTModels.Model},\n    d::Int64,\n    s::Symbol,\n    time::Symbol;\n    t_label,\n    labels,\n    title,\n    color,\n    kwargs...\n)\n\n\nPlot all components of a vector-valued signal over time.\n\nArguments\n\nd: Dimension of the signal (number of components).\nlabels: Vector of string labels for each component.\ntitle: Title of the subplot.\n\nOther arguments are the same as for the scalar version of __plot_time!.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot_time!-Tuple{Union{Plots.Plot, Plots.Subplot}, CTModels.Solution, Union{Nothing, CTModels.Model}, Symbol, Int64, Symbol}","page":"Plot","title":"CTModelsPlots.__plot_time!","text":"__plot_time!(\n    p::Union{Plots.Plot, Plots.Subplot},\n    sol::CTModels.Solution,\n    model::Union{Nothing, CTModels.Model},\n    s::Symbol,\n    i::Int64,\n    time::Symbol;\n    t_label,\n    y_label,\n    color,\n    kwargs...\n)\n\n\nPlot a single component i of a time-dependent vector-valued quantity (:state, :control, :costate, etc.).\n\nArguments\n\np: A Plots.Plot or Plots.Subplot object to update.\nsol: An optimal control Solution.\nmodel: The associated Model or nothing.\ns: Symbol indicating the signal type (:state, :control, :costate, :control_norm, etc.).\ni: Component index (use -1 for :control_norm).\ntime: Time normalization option (:default, :normalize, :normalise).\n\nKeyword Arguments\n\nt_label: Label for the time axis.\ny_label: Label for the vertical axis.\ncolor: color of the graph\nkwargs...: Additional plotting options.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot_tree","page":"Plot","title":"CTModelsPlots.__plot_tree","text":"__plot_tree(node::CTModelsPlots.PlotNode; ...) -> Any\n__plot_tree(\n    node::CTModelsPlots.PlotNode,\n    depth::Int64;\n    kwargs...\n) -> Any\n\n\nRecursively assemble a hierarchical plot layout from a PlotNode.\n\nEach node may represent a row, column, or custom layout and contain children (subplots or nested nodes).\n\nArguments\n\nnode: The root of a plot subtree.\ndepth: Current depth (used to control spacing/layout).\n\n\n\n\n\n","category":"function"},{"location":"plot.html#CTModelsPlots.__plot_tree-Tuple{CTModelsPlots.PlotLeaf, Int64}","page":"Plot","title":"CTModelsPlots.__plot_tree","text":"__plot_tree(\n    leaf::CTModelsPlots.PlotLeaf,\n    depth::Int64;\n    kwargs...\n) -> Plots.Plot\n\n\nReturn an empty plot for a PlotLeaf.\n\nUsed as a placeholder in layout trees.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#RecipesBase.apply_recipe","page":"Plot","title":"RecipesBase.apply_recipe","text":"apply_recipe(\n    plotattributes::AbstractDict{Symbol, Any},\n    sol::CTModels.Solution,\n    model::Union{Nothing, CTModels.Model},\n    xx::Union{Symbol, Tuple{Symbol, Int64}},\n    yy::Union{Symbol, Tuple{Symbol, Int64}}\n) -> Vector{RecipeData}\napply_recipe(\n    plotattributes::AbstractDict{Symbol, Any},\n    sol::CTModels.Solution,\n    model::Union{Nothing, CTModels.Model},\n    xx::Union{Symbol, Tuple{Symbol, Int64}},\n    yy::Union{Symbol, Tuple{Symbol, Int64}},\n    time::Symbol\n) -> Vector{RecipeData}\n\n\nA Plots.jl recipe for plotting Solution data.\n\nReturns the (x, y) values based on symbolic references like :state, :control, :time, etc.\n\nArguments\n\nxx: Symbol or (Symbol, Int) indicating the x-axis.\nyy: Symbol or (Symbol, Int) indicating the y-axis.\n\n\n\n\n\n","category":"function"},{"location":"plot.html#RecipesBase.plot!-Tuple{CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"RecipesBase.plot!","text":"plot!(\n    sol::CTModels.Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    color,\n    kwargs...\n) -> Any\n\n\nModify Plot current() with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#RecipesBase.plot!-Tuple{Plots.Plot, CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::CTModels.Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nModify Plot p with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#RecipesBase.plot-Tuple{CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"RecipesBase.plot","text":"plot(\n    sol::CTModels.Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the components of an optimal control solution.\n\nThis is the main user-facing function to visualise the solution of an optimal control problem solved with the control-toolbox ecosystem.\n\nIt generates a set of subplots showing the evolution of the state, control, costate, path constraints, and dual variables over time, depending on the problem and the userâ€™s choices.\n\nArguments\n\nsol::CTModels.Solution: The optimal control solution to visualise.\ndescription::Symbol...: A variable number of symbols indicating which components to include in the plot. Common values include:\n:state â€“ plot the state.\n:costate â€“ plot the costate (adjoint).\n:control â€“ plot the control.\n:path â€“ plot the path constraints.\n:dual â€“ plot the dual variables (or Lagrange multipliers) associated with path constraints.\n\nIf no symbols are provided, a default set is used based on the problem and styles.\n\nKeyword Arguments (Optional)\n\nlayout::Symbol = :group: Specifies how to arrange plots.\n:group: Fewer plots, grouping similar variables together (e.g., all states in one subplot).\n:split: One plot per variable component, stacked in a layout.\ncontrol::Symbol = :components: Defines how to represent control inputs.\n:components: One curve per control component.\n:norm: Single curve showing the Euclidean norm â€–u(t)â€–.\n:all: Plot both components and norm.\ntime::Symbol = :default: Time normalisation for plots.\n:default: Real time scale.\n:normalize or :normalise: Normalised to the interval [0, 1].\ncolor: set the color of the all the graphs.\n\nStyle Options (Optional)\n\nAll style-related keyword arguments can be either a NamedTuple of plotting attributes or the Symbol :none referring to not plot the associated element. These allow you to customise color, line style, markers, etc.\n\ntime_style: Style for vertical lines at initial and final times.\nstate_style: Style for state components.\ncostate_style: Style for costate components.\ncontrol_style: Style for control components.\npath_style: Style for path constraint values.\ndual_style: Style for dual variables.\n\nBounds Decorations (Optional)\n\nUse these options to customise bounds on the plots if applicable and defined in the model. Set to :none to hide.\n\nstate_bounds_style: Style for state bounds.\ncontrol_bounds_style: Style for control bounds.\npath_bounds_style: Style for path constraint bounds.\n\nReturns\n\nA Plots.Plot object, which can be displayed, saved, or further customised.\n\nExample\n\n# basic plot\njulia> plot(sol)\n\n# plot only the state and control\njulia> plot(sol, :state, :control)\n\n# customise layout and styles, no costate\njulia> plot(sol;\n       layout = :group,\n       control = :all,\n       state_style = (color=:blue, linestyle=:solid),\n       control_style = (color=:red, linestyle=:dash),\n       costate_style = :none)       \n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.clean-Tuple{Any}","page":"Plot","title":"CTModelsPlots.clean","text":"clean(description) -> Tuple\n\n\nClean and standardize the description tuple for plot selection.\n\nBehavior\n\nConverts plural forms (:states, :costates, etc.) to their singular equivalents.\nMaps ambiguous terms (:constraint, :constraints, :cons) to :path.\nRemoves duplicate symbols.\n\nArguments\n\ndescription: A tuple of symbols passed by the user, typically from plot arguments.\n\nReturns\n\nA cleaned Tuple{Symbol...} of unique, standardized symbols.\n\nExample\n\njulia> clean((:states, :controls, :costate, :constraint, :duals))\n# â†’ (:state, :control, :costate, :path, :dual)\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.do_decorate-Tuple{}","page":"Plot","title":"CTModelsPlots.do_decorate","text":"do_decorate(\n;\n    model,\n    time_style,\n    state_bounds_style,\n    control_bounds_style,\n    path_bounds_style\n)\n\n\nDetermine whether to decorate plots with bounds or time annotations.\n\nKeyword Arguments\n\nmodel: The associated OCP model. If nothing, decorations are skipped.\ntime_style: Style used for vertical lines marking initial/final time.\nstate_bounds_style: Style for state bounds lines.\ncontrol_bounds_style: Style for control bounds lines.\npath_bounds_style: Style for path constraint bounds.\n\nReturns\n\nA 4-tuple of booleans: (do_decorate_time, do_decorate_state_bounds, do_decorate_control_bounds, do_decorate_path_bounds)\n\nNotes\n\nEach decoration is applied only if:\n\nA non-:none style is provided, and\nA model is available (not nothing).\n\nExample\n\njulia> do_decorate(model=my_model, time_style=NamedTuple(), state_bounds_style=:none, ...)\n# â†’ (true, false, ...)\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.do_plot-Tuple{CTModels.Solution, Vararg{Symbol}}","page":"Plot","title":"CTModelsPlots.do_plot","text":"do_plot(\n    sol::CTModels.Solution,\n    description::Symbol...;\n    state_style,\n    control_style,\n    costate_style,\n    path_style,\n    dual_style\n)\n\n\nDetermine which components should be plotted based on the description and style settings.\n\nArguments\n\nsol: The optimal control solution.\ndescription: A cleaned tuple of plot description symbols (:state, :costate, :control, :path, :dual).\n\nKeyword Arguments\n\n*_style: The plotting style (a NamedTuple or :none). If a style is :none, that component is skipped.\n\nReturns\n\nA 5-tuple of booleans: (do_plot_state, do_plot_costate, do_plot_control, do_plot_path, do_plot_dual)\n\nNotes\n\nDuals are only plotted if sol contains path constraint dual variables.\nA style must not be :none for the component to be included.\n\nExample\n\njulia> do_plot(sol, :state, :control, :path; state_style=NamedTuple(), control_style=:none, path_style=NamedTuple(), ...)\n# â†’ (true, false, false, true, false)\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__control_layout-Tuple{}","page":"Plot","title":"CTModelsPlots.__control_layout","text":"__control_layout() -> Symbol\n\n\nDefault layout for control input visualization.\n\nReturns :components, which plots each control component individually.\n\nPossible values:\n\n:components: One plot per control component (default).\n:norm: Single plot showing the control norm â€–u(t)â€–.\n:all: Show both components and norm.\n\nUsed as the default for control in plot(sol; control=...).\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__description-Tuple{}","page":"Plot","title":"CTModelsPlots.__description","text":"__description() -> NTuple{12, Symbol}\n\n\nReturn the default list of description symbols to be plotted if the user does not specify any.\n\nIncludes aliases for backward compatibility.\n\nReturns a tuple of symbols, such as:\n\n:state, :costate, :control, :path, :dual, ...\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot_label_suffix-Tuple{}","page":"Plot","title":"CTModelsPlots.__plot_label_suffix","text":"__plot_label_suffix() -> String\n\n\nDefault suffix used for the solution label in plots.\n\nReturns an empty string \"\".\n\nThis label can be used to distinguish multiple solutions in comparative plots.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot_layout-Tuple{}","page":"Plot","title":"CTModelsPlots.__plot_layout","text":"__plot_layout() -> Symbol\n\n\nDefault layout for the full plot.\n\nReturns :split, which arranges each component (e.g. state, control) in separate subplots.\n\nPossible values:\n\n:split: One subplot per component (default).\n:group: Combine components into shared subplots.\n\nUsed as the default for layout in plot(sol; layout=...).\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__plot_style-Tuple{}","page":"Plot","title":"CTModelsPlots.__plot_style","text":"__plot_style() -> @NamedTuple{}\n\n\nDefault plot style.\n\nReturns an empty NamedTuple(), which means no style override is applied.\n\nUsed when no user-defined style is passed for plotting states, controls, etc.\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__size_plot-Tuple{CTModels.Solution, Union{Nothing, CTModels.Model}, Symbol, Symbol, Vararg{Symbol}}","page":"Plot","title":"CTModelsPlots.__size_plot","text":"__size_plot(\n    sol::CTModels.Solution,\n    model::Union{Nothing, CTModels.Model},\n    control::Symbol,\n    layout::Symbol,\n    description::Symbol...;\n    state_style,\n    control_style,\n    costate_style,\n    path_style,\n    dual_style\n)\n\n\nCompute a default size (width, height) for the plot figure.\n\nThis depends on the number of subplots, which is inferred from:\n\nThe layout (:group or :split)\nThe presence of state, control, costate, path constraint, or dual variable plots\nThe number of state and control variables\nThe control layout choice (:components, :norm, :all)\n\nUsed internally in the plot function to automatically size the output plot.\n\nExample\n\njulia> size = __size_plot(sol, model, :components, :split; ...)\n\n\n\n\n\n","category":"method"},{"location":"plot.html#CTModelsPlots.__time_normalization-Tuple{}","page":"Plot","title":"CTModelsPlots.__time_normalization","text":"__time_normalization() -> Symbol\n\n\nDefault time axis normalization.\n\nReturns :default, which plots against real time.\n\nPossible values:\n\n:default: Plot time in original units (default).\n:normalize: Normalize time to [0, 1].\n:normalise: Same as :normalize, British spelling.\n\nUsed as the default for time in plot(sol; time=...).\n\n\n\n\n\n","category":"method"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"Pages   = [\"default.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html#CTModels.__constraint_label-Tuple{}","page":"Default","title":"CTModels.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__constraints-Tuple{}","page":"Default","title":"CTModels.__constraints","text":"__constraints()\n\n\nUsed to set the default value for the constraints.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__control_components-Tuple{Int64, String}","page":"Default","title":"CTModels.__control_components","text":"__control_components(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"uâ‚\", \"uâ‚‚\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__control_name-Tuple{}","page":"Default","title":"CTModels.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__criterion_type-Tuple{}","page":"Default","title":"CTModels.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__filename_export_import-Tuple{}","page":"Default","title":"CTModels.__filename_export_import","text":"__filename_export_import() -> String\n\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__format-Tuple{}","page":"Default","title":"CTModels.__format","text":"__format() -> Symbol\n\n\nUsed to set the default value of the format of the file to be used for export and import.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__matrix_dimension_storage-Tuple{}","page":"Default","title":"CTModels.__matrix_dimension_storage","text":"__matrix_dimension_storage() -> Int64\n\n\nUsed to set the default value of the storage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__state_components-Tuple{Int64, String}","page":"Default","title":"CTModels.__state_components","text":"__state_components(n::Int64, name::String) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"xâ‚\", \"xâ‚‚\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__state_name-Tuple{}","page":"Default","title":"CTModels.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__time_name-Tuple{}","page":"Default","title":"CTModels.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__variable_components-Tuple{Int64, String}","page":"Default","title":"CTModels.__variable_components","text":"__variable_components(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"vâ‚\", \"vâ‚‚\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTModels.__variable_name-Tuple{Int64}","page":"Default","title":"CTModels.__variable_name","text":"__variable_name(q::Int64) -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils.html#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"utils.html","page":"Utils","title":"Utils","text":"Pages   = [\"utils.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"utils.html","page":"Utils","title":"Utils","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"utils.html#CTModels.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTModels.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn a linear interpolation function for the data f defined at points x.\n\nThis function creates a one-dimensional linear interpolant using the  Interpolations.jl package, with linear extrapolation beyond the bounds of x.\n\nArguments\n\nx: A vector of points at which the values f are defined.\nf: A vector of values to interpolate.\n\nReturns\n\nA callable interpolation object that can be evaluated at new points.\n\nExample\n\njulia> x = 0:0.5:2\njulia> f = [0.0, 1.0, 0.0, -1.0, 0.0]\njulia> interp = ctinterpolate(x, f)\njulia> interp(1.2)\n\n\n\n\n\n","category":"method"},{"location":"utils.html#CTModels.matrix2vec","page":"Utils","title":"CTModels.matrix2vec","text":"matrix2vec(A::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    A::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransform a matrix into a vector of vectors along the specified dimension.\n\nEach row or column of the matrix A is extracted and stored as an individual vector, depending on dim.\n\nArguments\n\nA: A matrix of elements of type <:ctNumber.\ndim: The dimension along which to split the matrix (1 for rows, 2 for columns). Defaults to 1.\n\nReturns\n\nA Vector of Vectors extracted from the rows or columns of A.\n\nNote\n\nThis is useful when data needs to be represented as a sequence of state or control vectors in optimal control problems.\n\nExample\n\njulia> A = [1 2 3; 4 5 6]\njulia> matrix2vec(A, 1)  # splits into rows: [[1, 2, 3], [4, 5, 6]]\njulia> matrix2vec(A, 2)  # splits into columns: [[1, 4], [2, 5], [3, 6]]\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTModels.to_out_of_place-Tuple{Any, Any}","page":"Utils","title":"CTModels.to_out_of_place","text":"to_out_of_place(\n    f!,\n    n;\n    T\n) -> Union{Nothing, CTModels.var\"#f#13\"{CTModels.var\"#f#12#14\"{DataType, _A, _B}} where {_A, _B}}\n\n\nConvert an in-place function f! to an out-of-place function f.\n\nThe resulting function f returns a vector of type T and length n by first allocating memory and then calling f! to fill it.\n\nArguments\n\nf!: An in-place function of the form f!(result, args...).\nn: The length of the output vector.\nT: The element type of the output vector (default is Float64).\n\nReturns\n\nAn out-of-place function f(args...; kwargs...) that returns the result as a vector or scalar, depending on n.\n\nExample\n\njulia> f!(r, x) = (r[1] = sin(x); r[2] = cos(x))\njulia> f = to_out_of_place(f!, 2)\njulia> f(Ï€/4)  # returns approximately [0.707, 0.707]\n\n\n\n\n\n","category":"method"},{"location":"utils.html#CTModels.@ensure-Tuple{Any, Any}","page":"Utils","title":"CTModels.@ensure","text":"@ensure condition exception\n\nThrows the provided exception if condition is false.\n\nUsage\n\njulia> @ensure x > 0 CTBase.IncorrectArgument(\"x must be positive\")\n\nArguments\n\ncondition: A Boolean expression to test.\nexception: An instance of an exception to throw if condition is false.\n\nThrows\n\nThe provided exception if the condition is not satisfied.\n\n\n\n\n\n","category":"macro"},{"location":"constraints.html#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints.html#Index","page":"Constraints","title":"Index","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"Pages   = [\"constraints.md\"]\nModules = [CTModels, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"constraints.html#Documentation","page":"Constraints","title":"Documentation","text":"","category":"section"},{"location":"constraints.html#Base.isempty-Tuple{CTModels.ConstraintsModel}","page":"Constraints","title":"Base.isempty","text":"isempty(model::CTModels.ConstraintsModel) -> Bool\n\n\nReturn if the constraints model is empty or not.\n\nArguments\n\nmodel: The constraints model to check for emptiness.\n\nReturns\n\nBool: Returns true if the model has no constraints, false otherwise.\n\nExample\n\n# Example of checking if a constraints model is empty\njulia> model = ConstraintsModel(...)\njulia> isempty(model)  # Returns true if there are no constraints\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.__constraint!-Tuple{OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}, Symbol, Int64, Int64, Int64}","page":"Constraints","title":"CTModels.__constraint!","text":"__constraint!(\n    ocp_constraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}},\n    type::Symbol,\n    n::Int64,\n    m::Int64,\n    q::Int64;\n    rg,\n    f,\n    lb,\n    ub,\n    label,\n    codim_f\n)\n\n\nAdd a constraint to a dictionary of constraints.\n\nArguments\n\nocp_constraints: The dictionary of constraints to which the constraint will be added.\ntype: The type of the constraint. It can be :state, :control, :variable, :boundary, or :path.\nn: The dimension of the state.\nm: The dimension of the control.\nq: The dimension of the variable.\nrg: The range of the constraint. It can be an integer or a range of integers.\nf: The function that defines the constraint. It must return a vector of the same dimension as the constraint.\nlb: The lower bound of the constraint. It can be a number or a vector.\nub: The upper bound of the constraint. It can be a number or a vector.\nlabel: The label of the constraint. It must be unique in the dictionary of constraints.\n\nRequirements\n\nThe constraint must not be set before.\nThe lower bound lb and the upper bound ub cannot be both nothing.\nThe lower bound lb and the upper bound ub must have the same length, if both provided.\n\nIf rg and f are not provided then, \n\ntype must be :state, :control, or :variable.\nlb and ub must be of dimension n, m, or q respectively, when provided.\n\nIf rg is provided, then:\n\nf must not be provided.\ntype must be :state, :control, or :variable.\nrg must be a range of integers, and must be contained in 1:n, 1:m, or 1:q respectively.\n\nIf f is provided, then:\n\nrg must not be provided.\ntype must be :boundary or :path.\nf must be a function that returns a vector of the same dimension as the constraint.\nlb and ub must be of the same dimension as the output of f, when provided.\n\nExample\n\n# Example of adding a state constraint\njulia> ocp_constraints = Dict()\njulia> __constraint!(ocp_constraints, :state, 3, 2, 1, lb=[0.0], ub=[1.0], label=:my_constraint)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, TB}}, Tuple{TB}} where TB","page":"Constraints","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    model::CTModels.ConstraintsModel{<:Tuple, TB}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the boundary constraints.\n\nReturns\n\nThe nonlinear boundary constraints.\n\nExample\n\n# Example of retrieving nonlinear boundary constraints\njulia> model = ConstraintsModel(...)\njulia> boundary_constraints = boundary_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"Constraints","title":"CTModels.constraint!","text":"constraint!(\n    ocp::CTModels.PreModel,\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label,\n    codim_f\n)\n\n\nAdd a constraint to a pre-model. See __constraint! for more details.\n\nArguments\n\nocp: The pre-model to which the constraint will be added.\ntype: The type of the constraint. It can be :state, :control, :variable, :boundary, or :path.\nrg: The range of the constraint. It can be an integer or a range of integers.\nf: The function that defines the constraint. It must return a vector of the same dimension as the constraint.\nlb: The lower bound of the constraint. It can be a number or a vector.\nub: The upper bound of the constraint. It can be a number or a vector.\nlabel: The label of the constraint. It must be unique in the pre-model.\n\nExample\n\n# Example of adding a control constraint to a pre-model\njulia> ocp = PreModel()\njulia> constraint!(ocp, :control, rg=1:2, lb=[0.0], ub=[1.0], label=:control_constraint)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.constraint-Tuple{CTModels.Model, Symbol}","page":"Constraints","title":"CTModels.constraint","text":"constraint(\n    model::CTModels.Model,\n    label::Symbol\n) -> Tuple{Symbol, Any, Any, Any}\n\n\nGet a labelled constraint from the model. Returns a tuple of the form (type, f, lb, ub) where type is the type of the constraint, f is the function,  lb is the lower bound and ub is the upper bound. \n\nThe function returns an exception if the label is not found in the model.\n\nArguments\n\nmodel: The model from which to retrieve the constraint.\nlabel: The label of the constraint to retrieve.\n\nReturns\n\nTuple: A tuple containing the type, function, lower bound, and upper bound of the constraint.\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.control_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}, Tuple{TC}} where TC","page":"Constraints","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}\n) -> Any\n\n\nGet the control box constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the control box constraints.\n\nReturns\n\nThe control box constraints.\n\nExample\n\n# Example of retrieving control box constraints\njulia> model = ConstraintsModel(...)\njulia> control_constraints = control_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"Constraints","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear boundary constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of boundary constraints.\n\nReturns\n\nDimension: The dimension of the nonlinear boundary constraints.\n\nExample\n\n# Example of getting the dimension of nonlinear boundary constraints\njulia> model = ConstraintsModel(...)\njulia> dim_boundary = dim_boundary_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.dim_control_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Constraints","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of control box constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of control box constraints.\n\nReturns\n\nDimension: The dimension of the control box constraints.\n\nExample\n\njulia> # Example of getting the dimension of control box constraints\njulia> model = ConstraintsModel(...)\njulia> dim_control = dim_control_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"Constraints","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of path constraints.\n\nReturns\n\nDimension: The dimension of the nonlinear path constraints.\n\nExample\n\n# Example of getting the dimension of nonlinear path constraints\njulia> model = ConstraintsModel(...)\njulia> dim_path = dim_path_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.dim_state_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Constraints","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of state box constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of state box constraints.\n\nReturns\n\nDimension: The dimension of the state box constraints.\n\nExample\n\njulia> # Example of getting the dimension of state box constraints\njulia> model = ConstraintsModel(...)\njulia> dim_state = dim_state_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"Constraints","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of variable box constraints.\n\nArguments\n\nmodel: The constraints model from which to retrieve the dimension of variable box constraints.\n\nReturns\n\nDimension: The dimension of the variable box constraints.\n\nExample\n\njulia> # Example of getting the dimension of variable box constraints\njulia> model = ConstraintsModel(...)\njulia> dim_variable = dim_variable_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{TP}}, Tuple{TP}} where TP","page":"Constraints","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    model::CTModels.ConstraintsModel{TP}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the path constraints.\n\nReturns\n\nThe nonlinear path constraints.\n\nExample\n\n# Example of retrieving nonlinear path constraints\njulia> model = ConstraintsModel(...)\njulia> path_constraints = path_constraints_nl(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.state_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}, Tuple{TS}} where TS","page":"Constraints","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}\n) -> Any\n\n\nGet the state box constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the state box constraints.\n\nReturns\n\nThe state box constraints.\n\nExample\n\n# Example of retrieving state box constraints\njulia> model = ConstraintsModel(...)\njulia> state_constraints = state_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}, Tuple{TV}} where TV","page":"Constraints","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}\n) -> Any\n\n\nGet the variable box constraints from the model.\n\nArguments\n\nmodel: The constraints model from which to retrieve the variable box constraints.\n\nReturns\n\nThe variable box constraints.\n\nExample\n\n# Example of retrieving variable box constraints\njulia> model = ConstraintsModel(...)\njulia> variable_constraints = variable_constraints_box(model)\n\n\n\n\n\n","category":"method"},{"location":"ctmodels.html#CTModels","page":"CTModels","title":"CTModels","text":"","category":"section"},{"location":"ctmodels.html#Index","page":"CTModels","title":"Index","text":"","category":"section"},{"location":"ctmodels.html","page":"CTModels","title":"CTModels","text":"Pages   = [\"ctmodels.md\"]\nModules = [CTModels, RecipesBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctmodels.html","page":"CTModels","title":"CTModels","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"ctmodels.html#Documentation","page":"CTModels","title":"Documentation","text":"","category":"section"},{"location":"ctmodels.html#CTModels.CTModels","page":"CTModels","title":"CTModels.CTModels","text":"CTModels module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nInterpolations\nMLStyle\nParameters\n\nList of all the exported names:\n\nplot\nplot!\n\n\n\n\n\n","category":"module"},{"location":"ctmodels.html#CTModels.TimesDisc","page":"CTModels","title":"CTModels.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.AbstractTag","page":"CTModels","title":"CTModels.AbstractTag","text":"abstract type AbstractTag\n\nAbstract type for export/import functions, used to choose between JSON or JLD extensions.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.ConstraintsDictType","page":"CTModels","title":"CTModels.ConstraintsDictType","text":"Type alias for a dictionnary of constraints. This is used to store constraints before building the model.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: ConstraintsModel, PreModel and Model.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.Dimension","page":"CTModels","title":"CTModels.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.JLD2Tag","page":"CTModels","title":"CTModels.JLD2Tag","text":"struct JLD2Tag <: CTModels.AbstractTag\n\nJLD tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.JSON3Tag","page":"CTModels","title":"CTModels.JSON3Tag","text":"struct JSON3Tag <: CTModels.AbstractTag\n\nJSON tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.Time","page":"CTModels","title":"CTModels.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.Times","page":"CTModels","title":"CTModels.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.ctNumber","page":"CTModels","title":"CTModels.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.ctVector","page":"CTModels","title":"CTModels.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = AbstractVector{<:ctNumber}\n\nSee also: ctNumber.\n\n\n\n\n\n","category":"type"},{"location":"ctmodels.html#CTModels.export_ocp_solution-Tuple{CTModels.AbstractSolution}","page":"CTModels","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    sol::CTModels.AbstractSolution;\n    format,\n    filename\n)\n\n\nExport a solution in JLD or JSON formats. Redirect to one of the methods:\n\nexport_ocp_solution(JLD2Tag(), sol, filename=filename)\nexport_ocp_solution(JSON3Tag(), sol, filename=filename)\n\nExamples\n\njulia> using JSON3\njulia> export_ocp_solution(sol; filename=\"solution\", format=:JSON)\njulia> using JLD2\njulia> export_ocp_solution(sol; filename=\"solution\", format=:JLD)  # JLD is the default\n\n\n\n\n\n","category":"method"},{"location":"ctmodels.html#CTModels.import_ocp_solution-Tuple{CTModels.AbstractModel}","page":"CTModels","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ocp::CTModels.AbstractModel;\n    format,\n    filename\n) -> Any\n\n\nImport a solution from a JLD or JSON file. Redirect to one of the methods:\n\nimport_ocp_solution(JLD2Tag(), ocp, filename=filename)\nimport_ocp_solution(JSON3Tag(), ocp, filename=filename)\n\nExamples\n\njulia> using JSON3\njulia> sol = import_ocp_solution(ocp; filename=\"solution\", format=:JSON)\njulia> using JLD2\njulia> sol = import_ocp_solution(ocp; filename=\"solution\", format=:JLD)  # JLD is the default\n\n\n\n\n\n","category":"method"},{"location":"model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"model.html#Index","page":"Model","title":"Index","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Pages   = [\"model.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"model.html#Documentation","page":"Model","title":"Documentation","text":"","category":"section"},{"location":"model.html#CTModels.append_box_constraints!-NTuple{8, Any}","page":"Model","title":"CTModels.append_box_constraints!","text":"append_box_constraints!(\n    inds,\n    lbs,\n    ubs,\n    labels,\n    rg,\n    lb,\n    ub,\n    label\n)\n\n\nAppends box constraint data to the provided vectors.\n\nArguments\n\ninds::Vector{Int}: Vector of indices to which the range rg will be appended.\nlbs::Vector{<:Real}: Vector of lower bounds to which lb will be appended.\nubs::Vector{<:Real}: Vector of upper bounds to which ub will be appended.\nlabels::Vector{String}: Vector of labels to which the label will be repeated and appended.\nrg::AbstractVector{Int}: Index range corresponding to the constraint variables.\nlb::AbstractVector{<:Real}: Lower bounds associated with rg.\nub::AbstractVector{<:Real}: Upper bounds associated with rg.\nlabel::String: Label describing the constraint block (e.g., \"state\", \"control\").\n\nNotes\n\nAll input vectors (rg, lb, ub) must have the same length.\nThe function modifies the inds, lbs, ubs, and labels vectors in-place.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB}}}, Tuple{TB}} where TB<:Tuple","page":"Model","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB<:Tuple}}\n) -> Any\n\n\nReturn the nonlinear boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.build-Tuple{CTModels.PreModel}","page":"Model","title":"CTModels.build","text":"build(\n    pre_ocp::CTModels.PreModel;\n    build_examodel\n) -> CTModels.Model{TD, var\"#s182\", var\"#s1821\", var\"#s1822\", var\"#s1823\", var\"#s1824\", var\"#s1825\", CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, Vector{Symbol}}, Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, Vector{Symbol}}, Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, Vector{Symbol}}}, Nothing} where {TD<:CTModels.TimeDependence, var\"#s182\"<:CTModels.AbstractTimesModel, var\"#s1821\"<:CTModels.AbstractStateModel, var\"#s1822\"<:CTModels.AbstractControlModel, var\"#s1823\"<:CTModels.AbstractVariableModel, var\"#s1824\"<:Function, var\"#s1825\"<:CTModels.AbstractObjectiveModel, TP<:Tuple{Vector{Float64}, Any, Vector{Float64}, Vector{Symbol}}, TB<:Tuple{Vector{Float64}, Any, Vector{Float64}, Vector{Symbol}}}\n\n\nConverts a mutable PreModel into an immutable Model.\n\nThis function finalizes a pre-defined optimal control problem (PreModel) by verifying that all necessary components (times, state, control, dynamics) are set. It then constructs a Model instance, incorporating optional components like objective and constraints if they are defined.\n\nArguments\n\npre_ocp::PreModel: The pre-defined optimal control problem to be finalized.\n\nReturns\n\nModel: A fully constructed model ready for solving.\n\nExample\n\njulia> pre_ocp = PreModel()\njulia> times!(pre_ocp, 0.0, 1.0, 100)\njulia> state!(pre_ocp, 2, \"x\", [\"x1\", \"x2\"])\njulia> control!(pre_ocp, 1, \"u\", [\"u1\"])\njulia> dynamics!(pre_ocp, (dx, t, x, u, v) -> dx .= x + u)\njulia> model = build(pre_ocp)\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.build-Tuple{OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}}","page":"Model","title":"CTModels.build","text":"build(\n    constraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n) -> CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, Vector{Symbol}}, Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, Vector{Symbol}}, Tuple{Vector{Float64}, Vector{Int64}, Vector{Float64}, Vector{Symbol}}} where {TP<:Tuple{Vector{Float64}, Any, Vector{Float64}, Vector{Symbol}}, TB<:Tuple{Vector{Float64}, Any, Vector{Float64}, Vector{Symbol}}}\n\n\nConstructs a ConstraintsModel from a dictionary of constraints.\n\nThis function processes a dictionary where each entry defines a constraint with its type, function or index range, lower and upper bounds, and label. It categorizes constraints into path, boundary, state, control, and variable constraints, assembling them into a structured ConstraintsModel.\n\nArguments\n\nconstraints::ConstraintsDictType: A dictionary mapping constraint labels to tuples of the form (type, function_or_range, lower_bound, upper_bound).\n\nReturns\n\nConstraintsModel: A structured model encapsulating all provided constraints.\n\nExample\n\njulia> constraints = OrderedDict(\n    :c1 => (:path, f1, [0.0], [1.0]),\n    :c2 => (:state, 1:2, [-1.0, -1.0], [1.0, 1.0])\n)\njulia> model = build(constraints)\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.constraints-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C}}, Tuple{C}} where C<:CTModels.AbstractConstraintsModel","page":"Model","title":"CTModels.constraints","text":"constraints(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nReturn the constraints struct.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.control-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, T}}, Tuple{T}} where T<:CTModels.AbstractControlModel","page":"Model","title":"CTModels.control","text":"control(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nReturn the control struct.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.control_components-Tuple{CTModels.Model}","page":"Model","title":"CTModels.control_components","text":"control_components(ocp::CTModels.Model) -> Vector{String}\n\n\nReturn the names of the components of the control.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.control_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}}, Tuple{TC}} where TC<:Tuple","page":"Model","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC<:Tuple}}\n) -> Any\n\n\nReturn the box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.control_dimension-Tuple{CTModels.Model}","page":"Model","title":"CTModels.control_dimension","text":"control_dimension(ocp::CTModels.Model) -> Int64\n\n\nReturn the control dimension.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.control_name-Tuple{CTModels.Model}","page":"Model","title":"CTModels.control_name","text":"control_name(ocp::CTModels.Model) -> String\n\n\nReturn the name of the control.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.criterion-Tuple{CTModels.Model}","page":"Model","title":"CTModels.criterion","text":"criterion(ocp::CTModels.Model) -> Symbol\n\n\nReturn the type of criterion (:min or :max).\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.Model}","page":"Model","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.dim_control_constraints_box-Tuple{CTModels.Model}","page":"Model","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.Model}","page":"Model","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.dim_state_constraints_box-Tuple{CTModels.Model}","page":"Model","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.Model}","page":"Model","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(ocp::CTModels.Model) -> Int64\n\n\nReturn the dimension of box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.dynamics-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D}}, Tuple{D}} where D<:Function","page":"Model","title":"CTModels.dynamics","text":"dynamics(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nReturn the dynamics.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.final_time-Tuple{CTModels.AbstractModel, AbstractVector}","page":"Model","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.AbstractModel,\n    variable::AbstractVector\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.final_time-Tuple{CTModels.AbstractModel}","page":"Model","title":"CTModels.final_time","text":"final_time(ocp::CTModels.AbstractModel) -> Real\n\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.final_time-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"Model","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nReturn the final time, for a fixed final time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"Model","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nReturn the final time, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, T}} where T<:Real","page":"Model","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nReturn the final time, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.final_time_name-Tuple{CTModels.Model}","page":"Model","title":"CTModels.final_time_name","text":"final_time_name(ocp::CTModels.Model) -> String\n\n\nReturn the name of the final time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.get_build_examodel-Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, <:Nothing}}","page":"Model","title":"CTModels.get_build_examodel","text":"get_build_examodel(\n    _::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, <:Nothing}\n)\n\n\nReturn an error (UnauthorizedCall) since the model is not built with the :exa backend.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.get_build_examodel-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, BE}}, Tuple{BE}} where BE<:Function","page":"Model","title":"CTModels.get_build_examodel","text":"get_build_examodel(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, BE<:Function}\n) -> Function\n\n\nReturn the build_examodel.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.has_fixed_final_time-Tuple{CTModels.Model}","page":"Model","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.has_fixed_initial_time-Tuple{CTModels.Model}","page":"Model","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.has_free_final_time-Tuple{CTModels.Model}","page":"Model","title":"CTModels.has_free_final_time","text":"has_free_final_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.has_free_initial_time-Tuple{CTModels.Model}","page":"Model","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(ocp::CTModels.Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.has_lagrange_cost-Tuple{CTModels.Model}","page":"Model","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.has_mayer_cost-Tuple{CTModels.Model}","page":"Model","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(ocp::CTModels.Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.initial_time-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"Model","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nReturn the initial time, for a fixed initial time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"Model","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nReturn the initial time, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}}, T}} where T<:Real","page":"Model","title":"CTModels.initial_time","text":"initial_time(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nReturn the initial time, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.initial_time_name-Tuple{CTModels.Model}","page":"Model","title":"CTModels.initial_time_name","text":"initial_time_name(ocp::CTModels.Model) -> String\n\n\nReturn the name of the initial time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.is_autonomous-Tuple{CTModels.Model{CTModels.Autonomous, <:CTModels.TimesModel}}","page":"Model","title":"CTModels.is_autonomous","text":"is_autonomous(\n    _::CTModels.Model{CTModels.Autonomous, <:CTModels.TimesModel}\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.is_autonomous-Tuple{CTModels.Model{CTModels.NonAutonomous, <:CTModels.TimesModel}}","page":"Model","title":"CTModels.is_autonomous","text":"is_autonomous(\n    _::CTModels.Model{CTModels.NonAutonomous, <:CTModels.TimesModel}\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.isempty_constraints-Tuple{CTModels.Model}","page":"Model","title":"CTModels.isempty_constraints","text":"isempty_constraints(ocp::CTModels.Model) -> Bool\n\n\nReturn true if the model has constraints or false if not.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L}}}, Tuple{L}} where L<:Function","page":"Model","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nReturn the Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.lagrange-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L}}}, Tuple{L}} where L<:Function","page":"Model","title":"CTModels.lagrange","text":"lagrange(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nReturn the Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"Model","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nReturn the Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.mayer-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"Model","title":"CTModels.mayer","text":"mayer(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nReturn the Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.objective-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:CTModels.AbstractObjectiveModel","page":"Model","title":"CTModels.objective","text":"objective(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nReturn the objective struct.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP}}}, Tuple{TP}} where TP<:Tuple","page":"Model","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP<:Tuple}}\n) -> Any\n\n\nReturn the nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.state-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, T}}, Tuple{T}} where T<:CTModels.AbstractStateModel","page":"Model","title":"CTModels.state","text":"state(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nReturn the state struct.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.state_components-Tuple{CTModels.Model}","page":"Model","title":"CTModels.state_components","text":"state_components(ocp::CTModels.Model) -> Vector{String}\n\n\nReturn the names of the components of the state.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.state_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}}, Tuple{TS}} where TS<:Tuple","page":"Model","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS<:Tuple}}\n) -> Any\n\n\nReturn the box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.state_dimension-Tuple{CTModels.Model}","page":"Model","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.Model) -> Int64\n\n\nReturn the state dimension.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.state_name-Tuple{CTModels.Model}","page":"Model","title":"CTModels.state_name","text":"state_name(ocp::CTModels.Model) -> String\n\n\nReturn the name of the state.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.time_name-Tuple{CTModels.Model}","page":"Model","title":"CTModels.time_name","text":"time_name(ocp::CTModels.Model) -> String\n\n\nReturn the name of the time.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.times-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, T}}, Tuple{T}} where T<:CTModels.TimesModel","page":"Model","title":"CTModels.times","text":"times(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nReturn the times struct.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.variable-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T}}, Tuple{T}} where T<:CTModels.AbstractVariableModel","page":"Model","title":"CTModels.variable","text":"variable(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nReturn the variable struct.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.variable_components-Tuple{CTModels.Model}","page":"Model","title":"CTModels.variable_components","text":"variable_components(ocp::CTModels.Model) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}}, Tuple{TV}} where TV<:Tuple","page":"Model","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    ocp::CTModels.Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV<:Tuple}}\n) -> Any\n\n\nReturn the box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.variable_dimension-Tuple{CTModels.Model}","page":"Model","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::CTModels.Model) -> Int64\n\n\nReturn the variable dimension.\n\n\n\n\n\n","category":"method"},{"location":"model.html#CTModels.variable_name-Tuple{CTModels.Model}","page":"Model","title":"CTModels.variable_name","text":"variable_name(ocp::CTModels.Model) -> String\n\n\nReturn the name of the variable.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#Variable","page":"Variable","title":"Variable","text":"","category":"section"},{"location":"variable.html#Index","page":"Variable","title":"Index","text":"","category":"section"},{"location":"variable.html","page":"Variable","title":"Variable","text":"Pages   = [\"variable.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"variable.html","page":"Variable","title":"Variable","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"variable.html#Documentation","page":"Variable","title":"Documentation","text":"","category":"section"},{"location":"variable.html#CTModels.components-Tuple{CTModels.EmptyVariableModel}","page":"Variable","title":"CTModels.components","text":"components(_::CTModels.EmptyVariableModel) -> Vector{String}\n\n\nReturn an empty vector since there are no variable components defined.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.components-Tuple{CTModels.VariableModelSolution}","page":"Variable","title":"CTModels.components","text":"components(\n    model::CTModels.VariableModelSolution\n) -> Vector{String}\n\n\nReturn the names of the components from the variable solution.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.components-Tuple{CTModels.VariableModel}","page":"Variable","title":"CTModels.components","text":"components(model::CTModels.VariableModel) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.dimension-Tuple{CTModels.EmptyVariableModel}","page":"Variable","title":"CTModels.dimension","text":"dimension(_::CTModels.EmptyVariableModel) -> Int64\n\n\nReturn 0 since no variable is defined.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.dimension-Tuple{CTModels.VariableModelSolution}","page":"Variable","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModelSolution) -> Int64\n\n\nReturn the number of components in the variable solution.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.dimension-Tuple{CTModels.VariableModel}","page":"Variable","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModel) -> Int64\n\n\nReturn the dimension (number of components) of the variable.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.name-Tuple{CTModels.EmptyVariableModel}","page":"Variable","title":"CTModels.name","text":"name(_::CTModels.EmptyVariableModel) -> String\n\n\nReturn an empty string, since no variable is defined.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.name-Tuple{CTModels.VariableModelSolution}","page":"Variable","title":"CTModels.name","text":"name(model::CTModels.VariableModelSolution) -> String\n\n\nReturn the name of the variable stored in the model solution.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.name-Tuple{CTModels.VariableModel}","page":"Variable","title":"CTModels.name","text":"name(model::CTModels.VariableModel) -> String\n\n\nReturn the name of the variable stored in the model.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.value-Union{Tuple{CTModels.VariableModelSolution{TS}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"Variable","title":"CTModels.value","text":"value(\n    model::CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the value stored in the variable solution model.\n\n\n\n\n\n","category":"method"},{"location":"variable.html#CTModels.variable!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Variable","title":"CTModels.variable!","text":"variable!(ocp::CTModels.PreModel, q::Int64)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol}\n)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine a new variable in the optimal control problem ocp with dimension q.\n\nThis function registers a named variable (e.g. \"state\", \"control\", or other) to be used in the problem definition. You may optionally specify a name and individual component names.\n\nnote: Note\nYou can call variable! only once. It must be called before setting the objective or dynamics.\n\nArguments\n\nocp: The PreModel where the variable is registered.\nq: The dimension of the variable (number of components).\nname: A name for the variable (default: auto-generated from q).\ncomponents_names: A vector of strings or symbols for each component (default: [\"vâ‚\", \"vâ‚‚\", ...]).\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [\"vâ‚\", \"vâ‚‚\"])\n\n\n\n\n\n","category":"method"},{"location":"state.html#State","page":"State","title":"State","text":"","category":"section"},{"location":"state.html#Index","page":"State","title":"Index","text":"","category":"section"},{"location":"state.html","page":"State","title":"State","text":"Pages   = [\"state.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"state.html","page":"State","title":"State","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"state.html#Documentation","page":"State","title":"Documentation","text":"","category":"section"},{"location":"state.html#CTModels.components-Tuple{CTModels.StateModelSolution}","page":"State","title":"CTModels.components","text":"components(\n    model::CTModels.StateModelSolution\n) -> Vector{String}\n\n\nGet the components names of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.components-Tuple{CTModels.StateModel}","page":"State","title":"CTModels.components","text":"components(model::CTModels.StateModel) -> Vector{String}\n\n\nGet the components names of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.dimension-Tuple{CTModels.StateModelSolution}","page":"State","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModelSolution) -> Int64\n\n\nGet the dimension of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.dimension-Tuple{CTModels.StateModel}","page":"State","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModel) -> Int64\n\n\nGet the dimension of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.name-Tuple{CTModels.StateModelSolution}","page":"State","title":"CTModels.name","text":"name(model::CTModels.StateModelSolution) -> String\n\n\nGet the name of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.name-Tuple{CTModels.StateModel}","page":"State","title":"CTModels.name","text":"name(model::CTModels.StateModel) -> String\n\n\nGet the name of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.state!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"State","title":"CTModels.state!","text":"state!(ocp::CTModels.PreModel, n::Int64)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol}\n)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"xâ‚\", \"xâ‚‚\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"yâ‚\", \"yâ‚‚\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"yâ‚\", \"yâ‚‚\"]\n\njulia> state!(ocp, 2, \"y\", [\"u\", \"v\"])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\njulia> state!(ocp, 2, \"y\", [:u, :v])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\n\n\n\n\n","category":"method"},{"location":"state.html#CTModels.value-Union{Tuple{CTModels.StateModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"State","title":"CTModels.value","text":"value(\n    model::CTModels.StateModelSolution{TS<:Function}\n) -> Function\n\n\nGet the state function from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#Objective","page":"Objective","title":"Objective","text":"","category":"section"},{"location":"objective.html#Index","page":"Objective","title":"Index","text":"","category":"section"},{"location":"objective.html","page":"Objective","title":"Objective","text":"Pages   = [\"objective.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"objective.html","page":"Objective","title":"Objective","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"objective.html#Documentation","page":"Objective","title":"Documentation","text":"","category":"section"},{"location":"objective.html#CTModels.criterion-Tuple{CTModels.BolzaObjectiveModel}","page":"Objective","title":"CTModels.criterion","text":"criterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.criterion-Tuple{CTModels.LagrangeObjectiveModel}","page":"Objective","title":"CTModels.criterion","text":"criterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.criterion-Tuple{CTModels.MayerObjectiveModel}","page":"Objective","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.has_lagrange_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"Objective","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(_::CTModels.BolzaObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.has_lagrange_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"Objective","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    _::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.has_lagrange_cost-Tuple{CTModels.MayerObjectiveModel}","page":"Objective","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(_::CTModels.MayerObjectiveModel) -> Bool\n\n\nReturn false.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.has_mayer_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"Objective","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(_::CTModels.BolzaObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.has_mayer_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"Objective","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(_::CTModels.LagrangeObjectiveModel) -> Bool\n\n\nReturn false.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.has_mayer_cost-Tuple{CTModels.MayerObjectiveModel}","page":"Objective","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(_::CTModels.MayerObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.lagrange-Union{Tuple{CTModels.BolzaObjectiveModel{<:Function, L}}, Tuple{L}} where L<:Function","page":"Objective","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nReturn the Lagrange function.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.lagrange-Union{Tuple{CTModels.LagrangeObjectiveModel{L}}, Tuple{L}} where L<:Function","page":"Objective","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nReturn the Lagrange function.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.mayer-Union{Tuple{CTModels.BolzaObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"Objective","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nReturn the Mayer function.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.mayer-Union{Tuple{CTModels.MayerObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"Objective","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nReturn the Mayer function.\n\n\n\n\n\n","category":"method"},{"location":"objective.html#CTModels.objective!","page":"Objective","title":"CTModels.objective!","text":"objective!(ocp::CTModels.PreModel; ...)\nobjective!(\n    ocp::CTModels.PreModel,\n    criterion::Symbol;\n    mayer,\n    lagrange\n)\n\n\nSet the objective of the optimal control problem.\n\nArguments\n\nocp::PreModel: the optimal control problem.\ncriterion::Symbol: the type of criterion. Either :min or :max. Default is :min.\nmayer::Union{Function, Nothing}: the Mayer function (inplace). Default is nothing.\nlagrange::Union{Function, Nothing}: the Lagrange function (inplace). Default is nothing.\n\nnote: Note\nThe state, control and variable must be set before the objective.\nThe objective must not be set before.\nAt least one of the two functions must be given. Please provide a Mayer or a Lagrange function.\n\nExamples\n\njulia> function mayer(x0, xf, v)\n           return x0[1] + xf[1] + v[1]\n       end\njulia> function lagrange(t, x, u, v)\n           return x[1] + u[1] + v[1]\n       end\njulia> objective!(ocp, :min, mayer=mayer, lagrange=lagrange)\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#Dynamics","page":"Dynamics","title":"Dynamics","text":"","category":"section"},{"location":"dynamics.html#Index","page":"Dynamics","title":"Index","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"Pages   = [\"dynamics.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"dynamics.html#Documentation","page":"Dynamics","title":"Documentation","text":"","category":"section"},{"location":"dynamics.html#CTModels.__build_dynamics_from_parts-Tuple{Vector{<:Tuple{var\"#s53\", var\"#s52\"} where {var\"#s53\"<:(AbstractRange{<:Int64}), var\"#s52\"<:Function}}}","page":"Dynamics","title":"CTModels.__build_dynamics_from_parts","text":"__build_dynamics_from_parts(\n    parts::Vector{<:Tuple{var\"#s53\", var\"#s52\"} where {var\"#s53\"<:(AbstractRange{<:Int64}), var\"#s52\"<:Function}}\n) -> CTModels.var\"#dyn!#64\"{Vector{var\"#s54\"}} where var\"#s54\"<:(Tuple{var\"#s53\", var\"#s52\"} where {var\"#s53\"<:(AbstractRange{<:Int64}), var\"#s52\"<:Function})\n\n\nBuild a combined dynamics function from multiple parts.\n\nThis function constructs an in-place dynamics function dyn! by composing several sub-functions, each responsible for updating a specific segment of the output vector.\n\nArguments\n\nparts::Vector{<:Tuple{<:AbstractRange{<:Int}, <:Function}}:  A vector of tuples, where each tuple contains:\nA range specifying the indices in the output vector val that the corresponding function updates.\nA function f with the signature (output_segment, t, x, u, v), which updates the slice of val indicated by the range.\n\nReturns\n\ndyn!: A function with signature (val, t, x, u, v) that updates the full output vector val in-place by applying each part function to its assigned segment.\n\nDetails\n\nThe returned dyn! function calls each part function with a view of val restricted to the assigned range. This avoids unnecessary copying and allows efficient updates of sub-vectors.\nEach part function is expected to modify its output segment in-place.\n\nExample\n\n# Define two sub-dynamics functions\njulia> f1(out, t, x, u, v) = out .= x[1:2] .+ u[1:2]\njulia> f2(out, t, x, u, v) = out .= x[3] * v\n\n# Combine them into one dynamics function affecting different parts of the output vector\njulia> parts = [(1:2, f1), (3:3, f2)]\njulia> dyn! = __build_dynamics_from_parts(parts)\n\nval = zeros(3)\njulia> dyn!(val, 0.0, [1.0, 2.0, 3.0], [0.5, 0.5], 2.0)\njulia> println(val)  # prints [1.5, 2.5, 6.0]\n\n\n\n\n\n","category":"method"},{"location":"dynamics.html#CTModels.dynamics!-Tuple{CTModels.PreModel, AbstractRange{<:Int64}, Function}","page":"Dynamics","title":"CTModels.dynamics!","text":"dynamics!(\n    ocp::CTModels.PreModel,\n    rg::AbstractRange{<:Int64},\n    f::Function\n)\n\n\nAdd a partial dynamics function f to the optimal control problem ocp, applying to the subset of state indices specified by the range rg.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\nrg::AbstractRange{<:Int}: Range of state indices to which f applies.\nf::Function: A function describing the dynamics over the specified state indices.\n\nPreconditions\n\nThe state, control, and times must be set before calling this function.\nThe full dynamics must not yet be complete.\nNo overlap is allowed between rg and existing dynamics index ranges.\n\nBehavior\n\nThis function appends the tuple (rg, f) to the list of partial dynamics. It ensures that the specified indices are not already covered and that the system is in a valid configuration for adding partial dynamics.\n\nErrors\n\nThrows CTBase.UnauthorizedCall if:\n\nThe state, control, or times are not yet set.\nThe dynamics are already defined completely.\nAny index in rg overlaps with an existing dynamics range.\n\nExample\n\njulia> dynamics!(ocp, 1:2, (out, t, x, u, v) -> out .= x[1:2] .+ u[1:2])\njulia> dynamics!(ocp, 3:3, (out, t, x, u, v) -> out .= x[3] * v[1])\n\n\n\n\n\n","category":"method"},{"location":"dynamics.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Function}","page":"Dynamics","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, f::Function)\n\n\nSet the full dynamics of the optimal control problem ocp using the function f.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\nf::Function: A function that defines the complete system dynamics.\n\nPreconditions\n\nThe state, control, and times must be set before calling this function.\nNo dynamics must have been set previously.\n\nBehavior\n\nThis function assigns f as the complete dynamics of the system. It throws an error if any of the required fields (state, control, times) are not yet set, or if dynamics have already been set.\n\nErrors\n\nThrows CTBase.UnauthorizedCall if called out of order or in an invalid state.\n\n\n\n\n\n","category":"method"},{"location":"dynamics.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Integer, Function}","page":"Dynamics","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, i::Integer, f::Function)\n\n\nDefine partial dynamics for a single state variable index in an optimal control problem.\n\nThis is a convenience method for defining dynamics affecting only one element of the state vector. It wraps the scalar index i into a range i:i and delegates to the general partial dynamics method.\n\nArguments\n\nocp::PreModel: The optimal control problem being defined.\ni::Integer: The index of the state variable to which the function f applies.\nf::Function: A function of the form (out, t, x, u, v) -> ..., which updates the scalar output out[1] in-place.\n\nBehavior\n\nThis is equivalent to calling:\n\njulia> dynamics!(ocp, i:i, f)\n\nErrors\n\nThrows the same errors as the range-based method if:\n\nThe model is not properly initialized.\nThe index i overlaps with existing dynamics.\nA full dynamics function is already defined.\n\nExample\n\njulia> dynamics!(ocp, 3, (out, t, x, u, v) -> out[1] = x[3]^2 + u[1])\n\n\n\n\n\n","category":"method"},{"location":"jld.html#JLD","page":"JLD","title":"JLD","text":"","category":"section"},{"location":"jld.html#Index","page":"JLD","title":"Index","text":"","category":"section"},{"location":"jld.html","page":"JLD","title":"JLD","text":"Pages   = [\"jld.md\"]\nModules = [CTModels, CTModelsJLD]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"jld.html","page":"JLD","title":"JLD","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"jld.html#Documentation","page":"JLD","title":"Documentation","text":"","category":"section"},{"location":"jld.html#CTModels.export_ocp_solution-Tuple{CTModels.JLD2Tag, CTModels.Solution}","page":"JLD","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    ::CTModels.JLD2Tag,\n    sol::CTModels.Solution;\n    filename\n)\n\n\nExport an optimal control solution to a .jld2 file using the JLD2 format.\n\nThis function serializes and saves a CTModels.Solution object to disk, allowing it to be reloaded later.\n\nArguments\n\n::CTModels.JLD2Tag: A tag used to dispatch the export method for JLD2.\nsol::CTModels.Solution: The optimal control solution to be saved.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base name of the file. The .jld2 extension is automatically appended.\n\nExample\n\njulia> using JLD2\njulia> export_ocp_solution(JLD2Tag(), sol; filename=\"mysolution\")\n# â†’ creates \"mysolution.jld2\"\n\n\n\n\n\n","category":"method"},{"location":"jld.html#CTModels.import_ocp_solution-Tuple{CTModels.JLD2Tag, CTModels.Model}","page":"JLD","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ::CTModels.JLD2Tag,\n    ocp::CTModels.Model;\n    filename\n)\n\n\nImport an optimal control solution from a .jld2 file.\n\nThis function loads a previously saved CTModels.Solution from disk.\n\nArguments\n\n::CTModels.JLD2Tag: A tag used to dispatch the import method for JLD2.\nocp::CTModels.Model: The associated model (used for dispatch consistency; not used internally).\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base name of the file. The .jld2 extension is automatically appended.\n\nReturns\n\nCTModels.Solution: The loaded solution object.\n\nExample\n\njulia> using JLD2\njulia> sol = import_ocp_solution(JLD2Tag(), model; filename=\"mysolution\")\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTModels.jl","page":"Introduction","title":"CTModels.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTModels.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"API Documentation","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = Main.API_PAGES\nDepth = 1","category":"page"},{"location":"control.html#Control","page":"Control","title":"Control","text":"","category":"section"},{"location":"control.html#Index","page":"Control","title":"Index","text":"","category":"section"},{"location":"control.html","page":"Control","title":"Control","text":"Pages   = [\"control.md\"]\nModules = [CTModels]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"control.html","page":"Control","title":"Control","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"control.html#Documentation","page":"Control","title":"Documentation","text":"","category":"section"},{"location":"control.html#CTModels.components-Tuple{CTModels.ControlModelSolution}","page":"Control","title":"CTModels.components","text":"components(\n    model::CTModels.ControlModelSolution\n) -> Vector{String}\n\n\nGet the names of the control components from the solution.\n\nArguments\n\nmodel::ControlModelSolution: The control model solution.\n\nReturns\n\nVector{String}: A list of control component names.\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.components-Tuple{CTModels.ControlModel}","page":"Control","title":"CTModels.components","text":"components(model::CTModels.ControlModel) -> Vector{String}\n\n\nGet the names of the control components.\n\nArguments\n\nmodel::ControlModel: The control model.\n\nReturns\n\nVector{String}: A list of control component names.\n\nExample\n\njulia> components(controlmodel)\n[\"uâ‚\", \"uâ‚‚\"]\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.control!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"Control","title":"CTModels.control!","text":"control!(ocp::CTModels.PreModel, m::Int64)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol}\n)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the control input for a given optimal control problem model.\n\nThis function sets the control dimension and optionally allows specifying the control name and the names of its components.\n\nnote: Note\nThis function should be called only once per model. Calling it again will raise an error.\n\nArguments\n\nocp::PreModel: The model to which the control will be added.\nm::Dimension: The control input dimension (must be greater than 0).\nname::Union{String,Symbol} (optional): The name of the control variable (default: \"u\").\ncomponents_names::Vector{<:Union{String,Symbol}} (optional): Names of the control components (default: automatically generated).\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_components(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_components(ocp)\n[\"uâ‚\", \"uâ‚‚\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_components(ocp)\n[\"vâ‚\", \"vâ‚‚\"]\n\njulia> control!(ocp, 2, \"v\", [\"a\", \"b\"])\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.dimension-Tuple{CTModels.ControlModelSolution}","page":"Control","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModelSolution) -> Int64\n\n\nGet the control input dimension from the solution.\n\nArguments\n\nmodel::ControlModelSolution: The control model solution.\n\nReturns\n\nDimension: The number of control components.\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.dimension-Tuple{CTModels.ControlModel}","page":"Control","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModel) -> Int64\n\n\nGet the control input dimension.\n\nArguments\n\nmodel::ControlModel: The control model.\n\nReturns\n\nDimension: The number of control components.\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.name-Tuple{CTModels.ControlModelSolution}","page":"Control","title":"CTModels.name","text":"name(model::CTModels.ControlModelSolution) -> String\n\n\nGet the name of the control variable from the solution.\n\nArguments\n\nmodel::ControlModelSolution: The control model solution.\n\nReturns\n\nString: The name of the control.\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.name-Tuple{CTModels.ControlModel}","page":"Control","title":"CTModels.name","text":"name(model::CTModels.ControlModel) -> String\n\n\nGet the name of the control variable.\n\nArguments\n\nmodel::ControlModel: The control model.\n\nReturns\n\nString: The name of the control.\n\nExample\n\njulia> name(controlmodel)\n\"u\"\n\n\n\n\n\n","category":"method"},{"location":"control.html#CTModels.value-Union{Tuple{CTModels.ControlModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"Control","title":"CTModels.value","text":"value(\n    model::CTModels.ControlModelSolution{TS<:Function}\n) -> Function\n\n\nGet the control function associated with the solution.\n\nArguments\n\nmodel::ControlModelSolution{TS}: The control model solution.\n\nReturns\n\nTS: A function giving the control value at a given time or state.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"solution.html#Index","page":"Solution","title":"Index","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Pages   = [\"solution.md\"]\nModules = [CTModels, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTModels\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTModels\njulia> x = 1\njulia> CTModels.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTModels: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"solution.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"solution.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Solution}","page":"Solution","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::CTModels.Solution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.boundary_constraints_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.build_solution-Union{Tuple{TPCD}, Tuple{TP}, Tuple{TU}, Tuple{TX}, Tuple{CTModels.Model, Vector{Float64}, TX, TU, Vector{Float64}, TP}} where {TX<:Union{Function, Matrix{Float64}}, TU<:Union{Function, Matrix{Float64}}, TP<:Union{Function, Matrix{Float64}}, TPCD<:Union{Nothing, Function, Matrix{Float64}}}","page":"Solution","title":"CTModels.build_solution","text":"build_solution(\n    ocp::CTModels.Model,\n    T::Vector{Float64},\n    X::Union{Function, Matrix{Float64}},\n    U::Union{Function, Matrix{Float64}},\n    v::Vector{Float64},\n    P::Union{Function, Matrix{Float64}};\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    status,\n    successful,\n    path_constraints_dual,\n    boundary_constraints_dual,\n    state_constraints_lb_dual,\n    state_constraints_ub_dual,\n    control_constraints_lb_dual,\n    control_constraints_ub_dual,\n    variable_constraints_lb_dual,\n    variable_constraints_ub_dual\n)\n\n\nBuild a solution from the optimal control problem, the time grid, the state, control, variable, and dual variables.\n\nArguments\n\nocp::Model: the optimal control problem.\nT::Vector{Float64}: the time grid.\nX::Matrix{Float64}: the state trajectory.\nU::Matrix{Float64}: the control trajectory.\nv::Vector{Float64}: the variable trajectory.\nP::Matrix{Float64}: the costate trajectory.\nobjective::Float64: the objective value.\niterations::Int: the number of iterations.\nconstraints_violation::Float64: the constraints violation.\nmessage::String: the message associated to the status criterion.\nstatus::Symbol: the status criterion.\nsuccessful::Bool: the successful status.\npath_constraints_dual::Matrix{Float64}: the dual of the path constraints.\nboundary_constraints_dual::Vector{Float64}: the dual of the boundary constraints.\nstate_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the state constraints.\nstate_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the state constraints.\ncontrol_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the control constraints.\ncontrol_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the control constraints.\nvariable_constraints_lb_dual::Vector{Float64}: the lower bound dual of the variable constraints.\nvariable_constraints_ub_dual::Vector{Float64}: the upper bound dual of the variable constraints.\n\nReturns\n\nsol::Solution: the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.constraints_violation-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.constraints_violation","text":"constraints_violation(sol::CTModels.Solution) -> Float64\n\n\nReturn the constraints violation.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.control-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"Solution","title":"CTModels.control","text":"control(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control as a function of time.\n\njulia> u  = control(sol)\njulia> t0 = time_grid(sol)[1]\njulia> u0 = u(t0) # control at the initial time\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.control_components-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.control_components","text":"control_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the control.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.control_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the control constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.control_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the control constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.control_dimension-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.control_dimension","text":"control_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the control.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.control_name-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.control_name","text":"control_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the control.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.costate-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co<:Function","page":"Solution","title":"CTModels.costate","text":"costate(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate as a function of time.\n\njulia> p  = costate(sol)\njulia> t0 = time_grid(sol)[1]\njulia> p0 = p(t0) # costate at the initial time\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.dual_model-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM}}, Tuple{DM}} where DM<:CTModels.AbstractDualModel","page":"Solution","title":"CTModels.dual_model","text":"dual_model(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM<:CTModels.AbstractDualModel}\n) -> CTModels.AbstractDualModel\n\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.final_time_name-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.final_time_name","text":"final_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the final time.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.infos-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.infos","text":"infos(sol::CTModels.Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.initial_time_name-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.initial_time_name","text":"initial_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the initial time.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.iterations-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.iterations","text":"iterations(sol::CTModels.Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method).\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.message-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.message","text":"message(sol::CTModels.Solution) -> String\n\n\nReturn the message associated to the status criterion.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.model-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, <:CTModels.AbstractDualModel, <:CTModels.AbstractSolverInfos, TM}}, Tuple{TM}} where TM<:CTModels.AbstractModel","page":"Solution","title":"CTModels.model","text":"model(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, <:CTModels.AbstractDualModel, <:CTModels.AbstractSolverInfos, TM<:CTModels.AbstractModel}\n) -> CTModels.AbstractModel\n\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.objective-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:Real","page":"Solution","title":"CTModels.objective","text":"objective(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.path_constraints_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the dual of the path constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.state-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"Solution","title":"CTModels.state","text":"state(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state as a function of time.\n\njulia> x  = state(sol)\njulia> t0 = time_grid(sol)[1]\njulia> x0 = x(t0) # state at the initial time\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.state_components-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.state_components","text":"state_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the state.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.state_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the state constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.state_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the state constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.state_dimension-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.state_dimension","text":"state_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the state.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.state_name-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.state_name","text":"state_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the state.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.status-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.status","text":"status(sol::CTModels.Solution) -> Symbol\n\n\nReturn the status criterion (a Symbol).\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.successful-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.successful","text":"successful(sol::CTModels.Solution) -> Bool\n\n\nReturn the successful status.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.time_grid-Union{Tuple{CTModels.Solution{<:CTModels.TimeGridModel{T}}}, Tuple{T}} where T<:Union{StepRangeLen, AbstractVector{<:Real}}","page":"Solution","title":"CTModels.time_grid","text":"time_grid(\n    sol::CTModels.Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.time_name-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.time_name","text":"time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the time component.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.variable-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"Solution","title":"CTModels.variable","text":"variable(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.variable_components-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.variable_components","text":"variable_components(\n    sol::CTModels.Solution\n) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.variable_constraints_lb_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the lower bound dual of the variable constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.variable_constraints_ub_dual-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the upper bound dual of the variable constraints.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.variable_dimension-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.variable_dimension","text":"variable_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the variable.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTModels.variable_name-Tuple{CTModels.Solution}","page":"Solution","title":"CTModels.variable_name","text":"variable_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the variable.\n\n\n\n\n\n","category":"method"}]
}
