using CTModels
using Plots
import CTParser: CTParser, @def

CTParser.set_prefix(:CTModels); # code generated by @def is prefixed by CTModels (not by OptimalControl - the default)

t0=0
tf=1
x0=[-1, 0]
xf=[0, 0]
γ = 5

# the model
function OCP(t0, tf, x0, xf, γ)

    A = [ 0 1
        0 0 ]
    B = [ 0
        1 ]

    @def ocp begin
        t ∈ [ t0, tf ], time
        x ∈ R², state
        u ∈ R, control
        x(t0) == x0,    (initial_con) 
        x(tf) == xf,    (final_con)
        -1 ≤ x₁(t) ≤ 1
        0 ≤ x₂(t) ≤ 2
        -γ ≤ u(t) ≤ γ,  (u_con)
        ẋ(t) == A * x(t) + B * u(t)
        ∫abs(u(t)) → min 
    end

    return ocp 
end;

ocp = OCP(t0, tf, x0, xf, γ);

# the solution
function SOL(ocp, t0, tf, x0, γ)

    a = x0[1]
    b = x0[2]

    tt1(α,β) = (β-1)/α
    tt2(α,β) = (β+1)/α

    tt1(p0) = tt1(p0...)
    tt2(p0) = tt2(p0...)

    # arc 1
    x_arc_1(t, α, β) = [ a + b*t + 0.5*γ*t^2, b + γ*t]; x_arc_1(t, p0) = x_arc_1(t, p0...)

    # arc 2
    c(α,β) = x_arc_1(tt1(α,β),α,β)[1]
    d(α,β) = x_arc_1(tt1(α,β),α,β)[2]

    x_arc_2(t,α,β) = [c(α,β)+ d(α,β)*(t-tt1(α,β)), d(α,β)]; x_arc_2(t, p0) = x_arc_2(t, p0...)

    # arc 3
    e(α,β) = x_arc_2(tt2(α,β),α,β)[1]
    f(α,β) = x_arc_2(tt2(α,β),α,β)[2]

    fp(α,β) = f(α,β) + γ*tt2(α,β)
    ep(α,β) = e(α,β) - fp(α,β)*tt2(α,β) + γ/2*tt2(α,β)^2

    x_arc_3(t,α,β) = [ep(α,β) + fp(α,β)*t - γ/2*t^2, fp(α,β) - γ*t]; x_arc_3(t, p0) = x_arc_3(t, p0...)

    # g(α,β) = x_arc_3(tf,α,β)[1]
    # h(α,β) = x_arc_3(tf,α,β)[2]    

    #
    p0 = [4.472135954999579, 2.23606797749979]

    #
    x(t) = (t ≤ tt1(p0))*x_arc_1(t,p0) + (tt1(p0) < t < tt2(p0))*x_arc_2(t,p0) + (t ≥ tt2(p0))*x_arc_3(t,p0)
    p(t) = [p0[1], -p0[1]*t + p0[2]]
    u(t) = (t ≤ tt1(p0))*γ + (tt1(p0) < t < tt2(p0))*0 + (t ≥ tt2(p0))*(-γ)
    v    = Float64[]
    objective = γ*(tt1(p0) + tf - tt2(p0))    

    # 
    times = range(t0, tf, 201)
    sol = CTModels.build_solution(ocp, 
        Vector{Float64}(times),
        x,
        u,
        v,
        p;
        objective=objective,
        iterations=-1,
        constraints_violation=0.0,
        message="",
        stopping=:optimal,
        success=true,
    )

    return sol
end;

sol = SOL(ocp, t0, tf, x0, γ);

plt = plot(sol, ocp, size=(800, 800))
